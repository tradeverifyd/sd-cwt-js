<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SD-CWT Playground | Tradeverifyd</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Host+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      /* Tradeverifyd Dark Mode Color Palette */
      --bg-primary: #050506;
      --bg-secondary: #1a1b1f;
      --bg-tertiary: #2D2E32;
      --bg-elevated: #3a3b40;
      
      /* Text Colors */
      --text-primary: #F5F7FA;
      --text-secondary: #B2B5BD;
      --text-muted: #51545C;
      
      /* Accent Colors */
      --accent-primary: #F2460D;
      --accent-primary-light: #ff6b3d;
      --accent-blue: #2F69C1;
      --accent-light-blue: #9FD0F8;
      
      /* Semantic Colors */
      --success-green: #3EC95E;
      --warning-yellow: #D6AF27;
      --error-red: #FF676C;
      
      /* Border & Effects */
      --border-color: #3a3b40;
      --border-subtle: #2D2E32;
      --glow-primary: 0 0 24px rgba(242, 70, 13, 0.25);
      --glow-blue: 0 0 20px rgba(47, 105, 193, 0.3);
      
      /* Glass Effect */
      --glass-bg: rgba(245, 247, 250, 0.06);
      --glass-border: rgba(245, 247, 250, 0.1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Host Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.6;
      position: relative;
    }

    /* Topographic Background Animation - Emergence Fade */
    @keyframes topoFade {
      0%, 100% {
        opacity: 0.4;
      }
      50% {
        opacity: 1;
      }
    }

    /* Topographic Background Pattern */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('topo-gradient.svg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      pointer-events: none;
      z-index: -1;
      animation: topoFade 12s ease-in-out infinite;
    }

    header {
      padding: 2.5rem 3rem;
      border-bottom: 1px solid var(--border-subtle);
      background: rgba(5, 5, 6, 0.9);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    .header-content {
      max-width: 900px;
      margin: 0 auto;
    }

    .brand-mark {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      margin-bottom: 0.75rem;
    }

    .brand-mark .logo-full {
      height: 32px;
      width: auto;
      flex-shrink: 0;
    }

    .brand-mark .divider {
      width: 1px;
      height: 28px;
      background: var(--border-color);
    }

    .brand-mark .product-name {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: -0.01em;
    }

    .brand-mark .product-name span {
      color: var(--accent-primary);
    }

    header p {
      color: var(--text-secondary);
      margin-top: 0.5rem;
      font-weight: 400;
      font-size: 0.95rem;
    }

    header p a {
      color: var(--accent-primary);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    header p a:hover {
      color: var(--accent-primary-light);
    }


    main {
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
    }

    /* Progress Bar - Clean Horizontal Stepper */
    .progress-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0;
      margin-bottom: 2rem;
      padding: 1.5rem 2rem;
      background: var(--bg-secondary);
      border-radius: 16px;
      border: 1px solid var(--border-subtle);
      position: relative;
    }

    .progress-step {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 70px;
    }

    .progress-step.disabled {
      cursor: not-allowed;
    }

    .progress-step.disabled .step-number,
    .progress-step.disabled .step-label {
      opacity: 0.4;
    }

    .step-connector {
      width: 40px;
      height: 2px;
      background: var(--border-color);
      transition: background 0.3s ease;
      flex-shrink: 0;
      align-self: center;
      margin-top: -1.25rem;
    }

    .step-connector.completed {
      background: var(--success-green);
    }

    .progress-step .step-number {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-tertiary);
      border: 2px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      color: var(--text-secondary);
    }

    .progress-step.active .step-number {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: white;
      box-shadow: var(--glow-primary);
    }

    .progress-step.completed .step-number {
      background: var(--success-green);
      border-color: var(--success-green);
      color: white;
    }

    .progress-step.completed .step-number::after {
      content: '‚úì';
    }

    .progress-step.completed .step-number span {
      display: none;
    }

    .progress-step .step-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      text-align: center;
      font-weight: 500;
      white-space: nowrap;
    }

    .progress-step.active .step-label {
      color: var(--accent-primary);
      font-weight: 600;
    }

    .progress-step.completed .step-label {
      color: var(--success-green);
    }

    /* Step Sections - Frosted Glass Cards */
    .workflow {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .step-section {
      background: var(--glass-bg);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .step-section.active {
      border-color: var(--accent-primary);
      box-shadow: var(--glow-primary);
    }

    .step-section.completed {
      border-color: var(--success-green);
    }

    .step-section.locked {
      opacity: 0.5;
    }

    .step-header {
      padding: 1.25rem 1.5rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .step-header:hover {
      background: rgba(255, 255, 255, 0.02);
    }

    .step-header-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .step-header .step-icon {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      background: var(--bg-tertiary);
    }

    .step-section.active .step-icon {
      background: var(--accent-primary);
    }

    .step-section.completed .step-icon {
      background: var(--success-green);
    }

    .step-header h2 {
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: -0.01em;
    }

    .step-header .step-status {
      font-size: 0.7rem;
      color: var(--text-muted);
      padding: 0.3rem 0.75rem;
      background: var(--bg-tertiary);
      border-radius: 20px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .step-section.active .step-status {
      background: rgba(242, 70, 13, 0.15);
      color: var(--accent-primary);
    }

    .step-section.completed .step-status {
      background: rgba(62, 201, 94, 0.15);
      color: var(--success-green);
    }

    .step-header .collapse-icon {
      font-size: 1rem;
      color: var(--text-muted);
      transition: transform 0.3s ease;
    }

    .step-section.expanded .collapse-icon {
      transform: rotate(180deg);
    }

    .step-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease, padding 0.4s ease;
    }

    .step-section.expanded .step-content {
      max-height: 2000px;
      padding: 0 1.5rem 1.5rem 1.5rem;
    }

    .step-actions {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid var(--border-subtle);
    }

    .step-actions button {
      flex: 1;
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: var(--bg-elevated);
      border-color: var(--text-muted);
    }

    .card {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .card:hover {
      border-color: var(--accent-primary);
      box-shadow: var(--glow-primary);
    }

    .card.issuer:hover {
      border-color: var(--accent-primary);
      box-shadow: var(--glow-primary);
    }

    .card.holder:hover {
      border-color: var(--accent-blue);
      box-shadow: var(--glow-blue);
    }

    .card.verifier:hover {
      border-color: var(--success-green);
      box-shadow: 0 0 20px rgba(62, 201, 94, 0.25);
    }

    .card-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-subtle);
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .card-header .icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
    }

    .issuer .card-header .icon {
      background: var(--accent-primary);
    }

    .holder .card-header .icon {
      background: var(--accent-blue);
    }

    .verifier .card-header .icon {
      background: var(--success-green);
    }

    .card-header h2 {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .card-body {
      padding: 1.5rem;
    }

    label {
      display: block;
      font-size: 0.8rem;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    textarea, input {
      width: 100%;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 0.875rem 1rem;
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      resize: vertical;
      transition: all 0.2s ease;
    }

    textarea:focus, input:focus {
      outline: none;
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(242, 70, 13, 0.1);
    }

    textarea {
      min-height: 120px;
    }

    textarea.tall {
      min-height: 200px;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    button {
      width: 100%;
      padding: 0.875rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-family: 'Host Grotesk', sans-serif;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      letter-spacing: 0.02em;
    }

    button.primary {
      background: var(--accent-primary);
      color: white;
    }

    button.primary:hover {
      background: var(--accent-primary-light);
      transform: translateY(-1px);
      box-shadow: var(--glow-primary);
    }

    .issuer button.primary {
      background: var(--accent-primary);
    }

    .holder button.primary {
      background: var(--accent-blue);
    }

    .holder button.primary:hover {
      box-shadow: var(--glow-blue);
    }

    .verifier button.primary {
      background: var(--success-green);
    }

    .verifier button.primary:hover {
      box-shadow: 0 0 20px rgba(62, 201, 94, 0.3);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .output-section {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid var(--border-subtle);
    }

    .output-label {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.75rem;
    }

    .hex-output {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      word-break: break-all;
      color: var(--accent-primary);
      max-height: 200px;
      overflow-y: auto;
      user-select: all;
    }

    .edn-output {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      white-space: pre-wrap;
      color: var(--text-primary);
      max-height: 400px;
      overflow-y: auto;
    }

    .edn-output .key {
      color: var(--accent-primary);
    }

    .edn-output .string {
      color: var(--success-green);
    }

    .edn-output .number {
      color: var(--warning-yellow);
    }

    .edn-output .tag {
      color: var(--accent-light-blue);
    }

    .edn-output .comment {
      color: var(--text-muted);
      font-style: italic;
    }

    .edn-output .hex {
      color: var(--accent-blue);
    }

    .edn-display {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      white-space: pre-wrap;
      color: var(--text-primary);
      max-height: 200px;
      overflow-y: auto;
    }

    .edn-display .edn-placeholder {
      color: var(--text-muted);
      font-style: italic;
    }

    .edn-display .comment {
      color: var(--text-muted);
      font-style: italic;
    }

    .edn-display .number {
      color: var(--warning-yellow);
    }

    .edn-display .hex {
      color: var(--accent-blue);
    }

    .edn-display .punctuation {
      color: var(--text-secondary);
    }

    .private-key-warning {
      margin-top: 0.5rem;
      padding: 0.5rem 0.75rem;
      background: rgba(214, 175, 39, 0.1);
      border: 1px solid var(--warning-yellow);
      border-radius: 6px;
      color: var(--warning-yellow);
      font-size: 0.8rem;
    }

    .status {
      padding: 0.75rem 1rem;
      border-radius: 8px;
      font-size: 0.85rem;
      margin-top: 1rem;
    }

    .status.success {
      background: rgba(62, 201, 94, 0.1);
      border: 1px solid var(--success-green);
      color: var(--success-green);
    }

    .status.error {
      background: rgba(255, 103, 108, 0.1);
      border: 1px solid var(--error-red);
      color: var(--error-red);
    }

    .status.info {
      background: rgba(242, 70, 13, 0.1);
      border: 1px solid var(--accent-primary);
      color: var(--accent-primary);
    }

    .disclosure-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .disclosure-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.625rem 0.875rem;
      background: var(--bg-tertiary);
      border-radius: 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
    }

    .disclosure-item input[type="checkbox"] {
      width: auto;
      accent-color: var(--accent-primary);
    }

    .disclosure-item .disclosure-key {
      color: var(--accent-primary);
      font-family: 'JetBrains Mono', monospace;
    }

    .disclosure-item .disclosure-sep {
      color: var(--text-muted);
    }

    .disclosure-item .disclosure-value {
      color: var(--success-green);
      font-family: 'JetBrains Mono', monospace;
    }

    .disclosure-item .disclosure-salt {
      color: var(--text-muted);
      font-size: 0.7rem;
      font-family: 'JetBrains Mono', monospace;
      margin-left: 0.5rem;
    }

    .disclosure-item .disclosure-array-parent {
      color: var(--accent-blue);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      margin-right: 0.25rem;
      opacity: 0.9;
    }

    .disclosure-item.decoy-item {
      background: linear-gradient(135deg, rgba(214, 175, 39, 0.08), rgba(214, 175, 39, 0.03));
      border: 1px dashed var(--warning-yellow);
      opacity: 0.85;
    }

    .disclosure-item .decoy-icon {
      font-size: 1rem;
      margin-right: 0.5rem;
    }

    .disclosure-item .decoy-label {
      color: var(--warning-yellow);
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
    }

    .disclosure-item .decoy-hint {
      color: var(--text-muted);
      font-size: 0.7rem;
      font-style: italic;
      margin-left: 0.5rem;
    }

    .key-section {
      background: var(--bg-tertiary);
      border-radius: 8px;
      padding: 1.25rem;
      margin-bottom: 1rem;
    }

    .key-section h3 {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .key-section h3::before {
      content: 'üîë';
      font-size: 0.9rem;
    }

    .small-btn {
      padding: 0.5rem 1rem;
      font-size: 0.75rem;
      width: auto;
      display: inline-block;
    }

    .btn-row {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .output-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .output-header .output-label {
      margin-bottom: 0;
    }

    .copy-btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 0.25rem 0.6rem;
      font-size: 0.7rem;
      border-radius: 4px;
      cursor: pointer;
      width: auto;
      transition: all 0.2s ease;
    }

    .copy-btn:hover {
      background: var(--bg-elevated);
      color: var(--text-primary);
      border-color: var(--accent-primary);
    }

    .tabs {
      display: flex;
      gap: 0;
      margin-bottom: 0;
    }

    .tab {
      padding: 0.5rem 1rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .tab.active {
      background: var(--bg-primary);
      color: var(--accent-primary);
      border-color: var(--accent-primary);
      border-bottom: 1px solid var(--bg-primary);
      margin-bottom: -1px;
    }

    .tab:hover:not(.active) {
      color: var(--text-primary);
    }

    .tab-content {
      border: 1px solid var(--border-color);
      border-radius: 0 8px 8px 8px;
    }

    .tab-content.active .tab:first-child {
      border-radius: 0;
    }

    footer {
      text-align: center;
      padding: 2.5rem 3rem;
      color: var(--text-secondary);
      font-size: 0.85rem;
      border-top: 1px solid var(--border-subtle);
      margin-top: 2rem;
      background: rgba(5, 5, 6, 0.9);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    footer a {
      color: var(--accent-primary);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    footer a:hover {
      color: var(--accent-primary-light);
    }

    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid transparent;
      border-top-color: currentColor;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 0.5rem;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .arrow-divider {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      color: var(--text-muted);
      padding: 0 0.5rem;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-elevated);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    @media (max-width: 1200px) {
      .arrow-divider {
        transform: rotate(90deg);
        padding: 1rem 0;
      }
    }

    @media (max-width: 768px) {
      header {
        padding: 1.5rem;
      }
      
      main {
        padding: 1rem;
      }
      
      .progress-bar {
        padding: 1rem;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      
      .progress-bar::before {
        display: none;
      }
      
      .step-header {
        flex-wrap: wrap;
        gap: 0.5rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <div class="brand-mark">
        <!-- Tradeverifyd Full Logo -->
        <img src="tradeverifyd-logo.svg" alt="Tradeverifyd" class="logo-full">
        <div class="divider"></div>
        <div class="product-name">SD-CWT <span>Playground</span></div>
      </div>
      <p>Interactive testing for Selective Disclosure CBOR Web Tokens ‚Ä¢ Pre-loaded with <a href="https://datatracker.ietf.org/doc/draft-ietf-spice-sd-cwt/" target="_blank">spec</a> examples</p>
    </div>
  </header>

  <main>
    <!-- Progress Bar -->
    <div class="progress-bar">
      <div class="progress-step active" data-step="1" onclick="goToStep(1)">
        <div class="step-number"><span>1</span></div>
        <div class="step-label">Holder Key</div>
      </div>
      <div class="step-connector"></div>
      <div class="progress-step disabled" data-step="2" onclick="goToStep(2)">
        <div class="step-number"><span>2</span></div>
        <div class="step-label">Issuer Key</div>
      </div>
      <div class="step-connector"></div>
      <div class="progress-step disabled" data-step="3" onclick="goToStep(3)">
        <div class="step-number"><span>3</span></div>
        <div class="step-label">Issue</div>
      </div>
      <div class="step-connector"></div>
      <div class="progress-step disabled" data-step="4" onclick="goToStep(4)">
        <div class="step-number"><span>4</span></div>
        <div class="step-label">Present</div>
      </div>
      <div class="step-connector"></div>
      <div class="progress-step disabled" data-step="5" onclick="goToStep(5)">
        <div class="step-number"><span>5</span></div>
        <div class="step-label">Verify</div>
      </div>
    </div>

    <div class="workflow">
      <!-- Step 1: Holder Key -->
      <div class="step-section active expanded" id="step1" data-step="1">
        <div class="step-header" onclick="toggleStep(1)">
          <div class="step-header-left">
            <div class="step-icon">1</div>
            <div>
              <h2>Step 1: Holder Key</h2>
              <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.25rem;">Generate or load the holder's key pair</p>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 1rem;">
            <span class="step-status" id="step1Status">Required</span>
            <span class="collapse-icon">‚ñº</span>
          </div>
        </div>
        <div class="step-content">
          <div class="form-group" style="margin-top: 0.5rem;">
            <label>Current Holder Key (EDN)</label>
            <div id="holderKeyEdnDisplay" class="edn-display" style="min-height: 100px;">
              <span class="edn-placeholder">Loading spec key...</span>
            </div>
            <div id="holderPrivateKeyWarning" class="private-key-warning" style="display: none;">
              ‚ö†Ô∏è Private key present (not shown for security)
            </div>
          </div>
          <details style="margin-top: 0.75rem;">
            <summary style="cursor: pointer; color: var(--text-secondary); font-size: 0.8rem;">Generate or Import Different Key</summary>
            <div style="margin-top: 0.75rem; display: flex; flex-direction: column; gap: 0.5rem;">
              <button class="btn-secondary" onclick="generateHolderKeyOnly()">Generate New Key</button>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="text" id="holderKeyHexInput" placeholder="Paste hex-encoded COSE key" style="font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; flex: 1;">
                <button class="btn-secondary small-btn" onclick="loadHolderKeyFromHexOnly()">Load</button>
              </div>
              <div id="holderKeyImportStatus"></div>
            </div>
          </details>
          <div class="step-actions">
            <button class="primary" onclick="completeStep(1)" id="step1Next">Continue</button>
          </div>
        </div>
      </div>

      <!-- Step 2: Issuer Key -->
      <div class="step-section locked" id="step2" data-step="2">
        <div class="step-header" onclick="toggleStep(2)">
          <div class="step-header-left">
            <div class="step-icon">2</div>
            <div>
              <h2>Step 2: Issuer Key</h2>
              <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.25rem;">Generate or load the issuer's key pair</p>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 1rem;">
            <span class="step-status" id="step2Status">Locked</span>
            <span class="collapse-icon">‚ñº</span>
          </div>
        </div>
        <div class="step-content">
          <div class="form-group" style="margin-top: 0.5rem;">
            <label>Current Issuer Key (EDN)</label>
            <div id="issuerKeyEdnDisplay" class="edn-display" style="min-height: 100px;">
              <span class="edn-placeholder">Loading spec key...</span>
            </div>
            <div id="issuerPrivateKeyWarning" class="private-key-warning" style="display: none;">
              ‚ö†Ô∏è Private key present (not shown for security)
            </div>
          </div>
          <details style="margin-top: 0.75rem;">
            <summary style="cursor: pointer; color: var(--text-secondary); font-size: 0.8rem;">Generate or Import Different Key</summary>
            <div style="margin-top: 0.75rem; display: flex; flex-direction: column; gap: 0.5rem;">
              <button class="btn-secondary" onclick="generateIssuerKeyOnly()">Generate New Key</button>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="text" id="issuerKeyHexInput" placeholder="Paste hex-encoded COSE key" style="font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; flex: 1;">
                <button class="btn-secondary small-btn" onclick="loadIssuerKeyFromHexOnly()">Load</button>
              </div>
              <div id="issuerKeyImportStatus"></div>
            </div>
          </details>
          <div class="step-actions">
            <button class="primary" onclick="completeStep(2)" id="step2Next">Continue</button>
          </div>
        </div>
      </div>

      <!-- Step 3: Issue SD-CWT -->
      <div class="step-section locked" id="step3" data-step="3">
        <div class="step-header" onclick="toggleStep(3)">
          <div class="step-header-left">
            <div class="step-icon">3</div>
            <div>
              <h2>Step 3: Issue SD-CWT</h2>
              <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.25rem;">Create the selectively disclosable CWT</p>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 1rem;">
            <span class="step-status" id="step3Status">Locked</span>
            <span class="collapse-icon">‚ñº</span>
          </div>
        </div>
        <div class="step-content">
          <div class="form-group">
            <label>Claims to be Issued (EDN)</label>
            <textarea id="issuerClaimsEdn" class="tall" placeholder='{
  1: "https://issuer.example",
  2: "https://device.example",
  58("ABCD-123456")
}'></textarea>
          </div>

          <div class="output-section" id="issuerOutput" style="display: none;">
            <div class="output-header">
              <div class="output-label">Issued SD-CWT (Hex)</div>
              <button class="copy-btn" onclick="copyToClipboard('issuedCwtHex')">Copy</button>
            </div>
            <div class="hex-output" id="issuedCwtHex"></div>
            <div id="issuerStatus"></div>
          </div>

          <div class="step-actions">
            <button class="primary" onclick="issueCWTAndContinue()" id="step3Next">Issue SD-CWT</button>
          </div>
        </div>
      </div>

      <!-- Step 4: Present -->
      <div class="step-section locked" id="step4" data-step="4">
        <div class="step-header" onclick="toggleStep(4)">
          <div class="step-header-left">
            <div class="step-icon">4</div>
            <div>
              <h2>Step 4: Create Presentation</h2>
              <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.25rem;">Select disclosures and create a presentation</p>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 1rem;">
            <span class="step-status" id="step4Status">Locked</span>
            <span class="collapse-icon">‚ñº</span>
          </div>
        </div>
        <div class="step-content">
          <textarea id="holderCwt" style="display: none;"></textarea>

          <div class="form-group">
            <label>Audience</label>
            <input type="text" id="holderAudience" placeholder="https://verifier.example.com">
          </div>

          <div class="form-group">
            <label>Nonce (optional)</label>
            <input type="text" id="holderNonce" placeholder="Random nonce for replay protection">
          </div>

          <div class="form-group" id="disclosureSelection" style="display: none;">
            <label>Select Disclosures</label>
            <div class="disclosure-list" id="disclosureList"></div>
          </div>

          <div class="output-section" id="holderOutput" style="display: none;">
            <div class="output-header">
              <div class="output-label">Presentation (SD-KBT Hex)</div>
              <button class="copy-btn" onclick="copyToClipboard('presentationHex')">Copy</button>
            </div>
            <div class="hex-output" id="presentationHex"></div>
            <div id="holderStatus"></div>
          </div>

          <div class="step-actions">
            <button class="primary" onclick="createPresentationAndContinue()" id="step4Next">Create Presentation</button>
          </div>
        </div>
      </div>

      <!-- Step 5: Verify -->
      <div class="step-section locked" id="step5" data-step="5">
        <div class="step-header" onclick="toggleStep(5)">
          <div class="step-header-left">
            <div class="step-icon">5</div>
            <div>
              <h2>Step 5: Verify Presentation</h2>
              <p style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.25rem;">Verify the presentation and view disclosed claims</p>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 1rem;">
            <span class="step-status" id="step5Status">Locked</span>
            <span class="collapse-icon">‚ñº</span>
          </div>
        </div>
        <div class="step-content">
          <textarea id="verifierPresentation" style="display: none;"></textarea>
          <input type="text" id="issuerPublicKeyForVerifier" style="display: none;">

          <div class="output-section" id="verifierInputDisplay">
            <div class="output-header">
              <div class="output-label">Presented SD-CWT (Hex)</div>
              <button class="copy-btn" onclick="copyToClipboard('presentedCwtHex')">Copy</button>
            </div>
            <div class="hex-output" id="presentedCwtHex" style="max-height: 120px;"></div>
          </div>

          <div class="form-group" style="margin-top: 1.5rem;">
            <label>Expected Audience</label>
            <input type="text" id="verifierAudience" placeholder="https://verifier.example.com">
          </div>

          <div class="form-group">
            <label>Expected Nonce (optional)</label>
            <input type="text" id="verifierNonce" placeholder="Expected nonce if required">
          </div>

          <div class="output-section" id="verifierOutput" style="display: none;">
            <div class="output-label">Verified Claims (EDN)</div>
            <div class="edn-output" id="verifiedClaimsEdn"></div>
            <div id="verifierStatus"></div>
          </div>

          <div class="step-actions">
            <button class="primary" onclick="verifyPresentationAndFinish()" id="step5Next">Verify Presentation</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer>
    <p>
      <strong>SD-CWT Implementation</strong> by Tradeverifyd ‚Ä¢ 
      <a href="https://datatracker.ietf.org/doc/draft-ietf-oauth-sd-cwt/" target="_blank">Specification</a> ‚Ä¢
      Built with Web Crypto API
    </p>
  </footer>

  <script src="js/sd-cwt.js"></script>
  <script>
    // ==========================================================================
    // Spec Test Keys from Appendix C of draft-ietf-spice-sd-cwt
    // ==========================================================================
    
    // C.1. Subject / Holder key (P-256 / ES256)
    const SPEC_HOLDER_KEY = {
      privateKey: {
        // /d/ -4 : h'5759a86e59bb3b002dde467da4b52f3d06e6c2cd439456cf0485b9b864294ce5'
        d: hexToBytes('5759a86e59bb3b002dde467da4b52f3d06e6c2cd439456cf0485b9b864294ce5'),
        // /x/ -2 : h'8554eb275dcd6fbd1c7ac641aa2c90d92022fd0d3024b5af18c7cc61ad527a2d'
        x: hexToBytes('8554eb275dcd6fbd1c7ac641aa2c90d92022fd0d3024b5af18c7cc61ad527a2d'),
        // /y/ -3 : h'4dc7ae2c677e96d0cc82597655ce92d5503f54293d87875d1e79ce4770194343'
        y: hexToBytes('4dc7ae2c677e96d0cc82597655ce92d5503f54293d87875d1e79ce4770194343'),
      },
      publicKey: {
        x: hexToBytes('8554eb275dcd6fbd1c7ac641aa2c90d92022fd0d3024b5af18c7cc61ad527a2d'),
        y: hexToBytes('4dc7ae2c677e96d0cc82597655ce92d5503f54293d87875d1e79ce4770194343'),
      },
      algorithm: 'ES256',
      curve: 'P-256',
    };

    // C.2. Issuer key (P-384 / ES384)
    const SPEC_ISSUER_KEY = {
      privateKey: {
        // /d/ -4 : h'71c54d2221937ea612db1221f0d3ddf771c9381c4e3be41d5aa0a89d685f09cfef74c4bbf104783fd57e87ab227d074c'
        d: hexToBytes('71c54d2221937ea612db1221f0d3ddf771c9381c4e3be41d5aa0a89d685f09cfef74c4bbf104783fd57e87ab227d074c'),
        // /x/ -2 : h'c31798b0c7885fa3528fbf877e5b4c3a6dc67a5a5dc6b307b728c3725926f2abe5fb4964cd91e3948a5493f6ebb6cbbf'
        x: hexToBytes('c31798b0c7885fa3528fbf877e5b4c3a6dc67a5a5dc6b307b728c3725926f2abe5fb4964cd91e3948a5493f6ebb6cbbf'),
        // /y/ -3 : h'8f6c7ec761691cad374c4daa9387453f18058ece58eb0a8e84a055a31fb7f9214b27509522c159e764f8711e11609554'
        y: hexToBytes('8f6c7ec761691cad374c4daa9387453f18058ece58eb0a8e84a055a31fb7f9214b27509522c159e764f8711e11609554'),
      },
      publicKey: {
        x: hexToBytes('c31798b0c7885fa3528fbf877e5b4c3a6dc67a5a5dc6b307b728c3725926f2abe5fb4964cd91e3948a5493f6ebb6cbbf'),
        y: hexToBytes('8f6c7ec761691cad374c4daa9387453f18058ece58eb0a8e84a055a31fb7f9214b27509522c159e764f8711e11609554'),
      },
      algorithm: 'ES384',
      curve: 'P-384',
    };

    // Use library's Hex utilities
    function hexToBytes(hex) {
      return SDCWT.Hex.decode(hex);
    }

    // ==========================================================================
    // State
    // ==========================================================================
    let issuerKeyPair = null;
    let holderKeyPair = null;
    let issuerAlgorithm = 'ES384';  // Spec uses ES384 for issuer
    let holderAlgorithm = 'ES256';  // Spec uses ES256 for holder
    let issuedToken = null;
    let disclosures = [];
    let decoyCount = 0;  // Track number of decoys from EDN
    let arrayDisclosureInfo = [];  // Track which arrays disclosures belong to

    // ==========================================================================
    // Initialize with Spec Example Data (Section 13.1)
    // ==========================================================================
    
    // Claims from Section 10 & 13.1 examples in EDN format
    // This example demonstrates ALL SD-CWT features:
    // - Tag 58 on map keys: marks key-value pairs for redaction
    // - Tag 58 on array elements: marks array elements for redaction  
    // - Tag 61 (decoys): inserts fake redacted entries to hide count
    // The cnf claim (8) will be auto-populated from the holder's public key
    const SPEC_CLAIMS_EDN = `{
  / iss / 1: "https://issuer.example",
  / sub / 2: "https://device.example",
  / exp / 4: 1725330600,
  / nbf / 5: 1725243900,
  / iat / 6: 1725244200,
  / cnf / 8: {
    / COSE_Key / 1: {
      / kty: EC2 / 1: 2,
      / crv: P-256 / -1: 1,
      / x / -2: h'8554eb275dcd6fbd1c7ac641aa2c90d92022fd0d3024b5af18c7cc61ad527a2d',
      / y / -3: h'4dc7ae2c677e96d0cc82597655ce92d5503f54293d87875d1e79ce4770194343'
    }
  },
  / most_recent_inspection_passed / 500: true,
  / to be redacted: inspector_license_number / 58(501): "ABCD-123456",
  / inspection_dates - array with redacted elements / 502: [
    / to be redacted: date 7-Feb-2019 / 58(1549560720),
    / to be redacted: date 4-Feb-2021 / 58(1612560720),
    / public: date 17-Jan-2023 / 1674004740
  ],
  / inspection_location / 503: {
    "country": "us",
    / to be redacted / 58("region"): "ca",
    / to be redacted / 58("postal_code"): "94188",
    / decoy: adds 1 fake redacted entry / 61(1): null
  },
  / decoy: adds 1 fake redacted entry at top level / 61(1): null
}`;

    document.getElementById('issuerClaimsEdn').value = SPEC_CLAIMS_EDN;
    document.getElementById('holderAudience').value = 'https://verifier.example';
    document.getElementById('verifierAudience').value = 'https://verifier.example';

    // ==========================================================================
    // Key Management - Using COSE Key format (serialized as hex)
    // ==========================================================================
    
    function loadSpecIssuerKey() {
      try {
        // Convert spec key to COSE Key Map format
        issuerKeyPair = {
          privateKey: createCoseKeyMap(SPEC_ISSUER_KEY.privateKey, 'ES384', true),
          publicKey: createCoseKeyMap(SPEC_ISSUER_KEY.publicKey, 'ES384', false),
        };
        issuerAlgorithm = 'ES384';
        
        updateKeyDisplay('issuer', issuerKeyPair.publicKey, 'Spec ES384', true);
        showStatus('issuerStatus', 'Loaded Spec Issuer Key (ES384/P-384)', 'success');
      } catch (error) {
        showStatus('issuerStatus', 'Failed to load spec key: ' + error.message, 'error');
      }
    }

    function loadSpecHolderKey() {
      try {
        // Convert spec key to COSE Key Map format
        holderKeyPair = {
          privateKey: createCoseKeyMap(SPEC_HOLDER_KEY.privateKey, 'ES256', true),
          publicKey: createCoseKeyMap(SPEC_HOLDER_KEY.publicKey, 'ES256', false),
        };
        holderAlgorithm = 'ES256';
        
        updateKeyDisplay('holder', holderKeyPair.publicKey, 'Spec ES256', true);
        showStatus('holderStatus', 'Loaded Spec Holder Key (ES256/P-256)', 'success');
      } catch (error) {
        showStatus('holderStatus', 'Failed to load spec key: ' + error.message, 'error');
      }
    }

    async function generateIssuerKey() {
      try {
        // Generate new ES256 key pair (P-256)
        const keyPair = await generateWebCryptoKeyPair('P-256');
        const privateKey = createCoseKeyMap(keyPair.privateKey, 'ES256', true);
        const publicKey = createCoseKeyMap(keyPair.publicKey, 'ES256', false);
        
        // Compute thumbprint and set as kid
        const thumbprintHex = SDCWT.coseSign1.coseKeyThumbprint(publicKey);
        const thumbprintBytes = SDCWT.Hex.decode(thumbprintHex);
        privateKey.set(2, thumbprintBytes);  // kid
        publicKey.set(2, thumbprintBytes);   // kid
        
        issuerKeyPair = { privateKey, publicKey };
        issuerAlgorithm = 'ES256';
        
        updateKeyDisplay('issuer', issuerKeyPair.publicKey, 'New ES256', true);
        showStatus('issuerStatus', 'New Issuer Key generated (ES256/P-256) with kid', 'success');
      } catch (error) {
        showStatus('issuerStatus', 'Key generation failed: ' + error.message, 'error');
      }
    }

    async function generateHolderKey() {
      try {
        // Generate new ES256 key pair (P-256)
        const keyPair = await generateWebCryptoKeyPair('P-256');
        const privateKey = createCoseKeyMap(keyPair.privateKey, 'ES256', true);
        const publicKey = createCoseKeyMap(keyPair.publicKey, 'ES256', false);
        
        // Compute thumbprint and set as kid
        const thumbprintHex = SDCWT.coseSign1.coseKeyThumbprint(publicKey);
        const thumbprintBytes = SDCWT.Hex.decode(thumbprintHex);
        privateKey.set(2, thumbprintBytes);  // kid
        publicKey.set(2, thumbprintBytes);   // kid
        
        holderKeyPair = { privateKey, publicKey };
        holderAlgorithm = 'ES256';
        
        updateKeyDisplay('holder', holderKeyPair.publicKey, 'New ES256', true);
        showStatus('holderStatus', 'New Holder Key generated (ES256/P-256) with kid', 'success');
      } catch (error) {
        showStatus('holderStatus', 'Key generation failed: ' + error.message, 'error');
      }
    }

    // Update key display with thumbprint
    function updateKeyDisplay(role, publicKey, label, hasPrivateKey = false) {
      const publicKeyHex = SDCWT.coseSign1.coseKeyToHex(publicKey);
      const keyEdnHtml = formatCoseKeyAsEdnHtml(publicKey);
      
      if (role === 'issuer') {
        document.getElementById('issuerPublicKeyForVerifier').value = publicKeyHex;
        document.getElementById('issuerKeyEdnDisplay').innerHTML = keyEdnHtml;
        document.getElementById('issuerPrivateKeyWarning').style.display = hasPrivateKey ? 'block' : 'none';
      } else {
        document.getElementById('holderKeyEdnDisplay').innerHTML = keyEdnHtml;
        document.getElementById('holderPrivateKeyWarning').style.display = hasPrivateKey ? 'block' : 'none';
        // Update the cnf claim in the EDN textarea
        updateCnfClaimInEdn(publicKey);
      }
    }
    
    // Format a COSE Key Map as EDN string with HTML syntax highlighting
    // Ellide long hex strings for display: h'75726e3a...32636573'
    function ellideHex(hexStr, maxLength = 24) {
      if (hexStr.length <= maxLength) {
        return hexStr;
      }
      const prefixLen = 8;
      const suffixLen = 8;
      return hexStr.slice(0, prefixLen) + '...' + hexStr.slice(-suffixLen);
    }

    function formatCoseKeyAsEdnHtml(coseKey) {
      const kty = coseKey.get(1);
      const alg = coseKey.get(3);
      const crv = coseKey.get(-1);
      const x = coseKey.get(-2);
      const y = coseKey.get(-3);
      
      // Always compute the thumbprint to show as kid (CKT)
      const thumbprint = SDCWT.coseSign1.coseKeyThumbprint(coseKey);
      
      // Get curve and algorithm names
      const crvName = crv === 1 ? 'P-256' : crv === 2 ? 'P-384' : `${crv}`;
      const algName = alg === -7 ? 'ES256' : alg === -35 ? 'ES384' : alg ? `${alg}` : null;
      
      // Helper for syntax highlighting
      const comment = (text) => `<span class="comment">/ ${text} /</span>`;
      const num = (n) => `<span class="number">${n}</span>`;
      const hex = (h, ellide = true) => {
        const display = ellide ? ellideHex(h) : h;
        const title = h.length > 24 ? ` title="${h}"` : '';
        return `<span class="hex"${title}>h'${display}'</span>`;
      };
      const punc = (p) => `<span class="punctuation">${p}</span>`;
      
      let lines = [punc('{')];
      lines.push(`  ${comment('kty: EC2')} ${num(1)}${punc(':')} ${num(2)}${punc(',')}`);
      
      // Always show kid as the computed thumbprint (CKT)
      lines.push(`  ${comment('kid: CKT')} ${num(2)}${punc(':')} ${hex(thumbprint)}${punc(',')}`);
      
      if (alg) {
        lines.push(`  ${comment('alg: ' + algName)} ${num(3)}${punc(':')} ${num(alg)}${punc(',')}`);
      }
      
      lines.push(`  ${comment('crv: ' + crvName)} ${num(-1)}${punc(':')} ${num(crv)}${punc(',')}`);
      lines.push(`  ${comment('x')} ${num(-2)}${punc(':')} ${hex(SDCWT.Hex.encode(x))}${punc(',')}`);
      lines.push(`  ${comment('y')} ${num(-3)}${punc(':')} ${hex(SDCWT.Hex.encode(y))}`);
      
      lines.push(punc('}'));
      return lines.join('\n');
    }
    
    // Load holder key from hex input
    function loadHolderKeyFromHex() {
      try {
        const hexInput = document.getElementById('holderKeyHexInput').value.trim();
        if (!hexInput) {
          showStatus('holderKeyImportStatus', 'Please enter a hex-encoded COSE key', 'error');
          return;
        }
        
        const coseKey = SDCWT.coseKeyFromHex(hexInput);
        const crv = coseKey.get(-1);
        const hasPrivateKey = coseKey.has(-4);
        
        // Determine algorithm from curve
        const alg = crv === 1 ? 'ES256' : crv === 2 ? 'ES384' : 'ES256';
        holderAlgorithm = alg;
        
        if (hasPrivateKey) {
          // Full key pair
          const publicKey = new Map();
          publicKey.set(1, coseKey.get(1));
          if (coseKey.has(2)) publicKey.set(2, coseKey.get(2));
          if (coseKey.has(3)) publicKey.set(3, coseKey.get(3));
          publicKey.set(-1, coseKey.get(-1));
          publicKey.set(-2, coseKey.get(-2));
          publicKey.set(-3, coseKey.get(-3));
          
          holderKeyPair = {
            privateKey: coseKey,
            publicKey: publicKey
          };
        } else {
          // Public key only - can be used for cnf but not for signing
          holderKeyPair = {
            privateKey: null,
            publicKey: coseKey
          };
        }
        
        updateKeyDisplay('holder', holderKeyPair.publicKey, `Imported ${alg}`, hasPrivateKey);
        showStatus('holderKeyImportStatus', `Loaded ${hasPrivateKey ? 'key pair' : 'public key'} (${alg})`, 'success');
        showStatus('holderStatus', `Loaded ${hasPrivateKey ? 'key pair' : 'public key'} from hex`, 'success');
      } catch (error) {
        showStatus('holderKeyImportStatus', 'Failed to parse key: ' + error.message, 'error');
      }
    }
    
    // Load issuer key from hex input
    function loadIssuerKeyFromHex() {
      try {
        const hexInput = document.getElementById('issuerKeyHexInput').value.trim();
        if (!hexInput) {
          showStatus('issuerKeyImportStatus', 'Please enter a hex-encoded COSE key', 'error');
          return;
        }
        
        const coseKey = SDCWT.coseKeyFromHex(hexInput);
        const crv = coseKey.get(-1);
        const hasPrivateKey = coseKey.has(-4);
        
        if (!hasPrivateKey) {
          showStatus('issuerKeyImportStatus', 'Issuer key must include private key for signing', 'error');
          return;
        }
        
        // Determine algorithm from curve
        const alg = crv === 1 ? 'ES256' : crv === 2 ? 'ES384' : 'ES256';
        issuerAlgorithm = alg;
        
        // Create public-only version
        const publicKey = new Map();
        publicKey.set(1, coseKey.get(1));
        if (coseKey.has(2)) publicKey.set(2, coseKey.get(2));
        if (coseKey.has(3)) publicKey.set(3, coseKey.get(3));
        publicKey.set(-1, coseKey.get(-1));
        publicKey.set(-2, coseKey.get(-2));
        publicKey.set(-3, coseKey.get(-3));
        
        issuerKeyPair = {
          privateKey: coseKey,
          publicKey: publicKey
        };
        
        updateKeyDisplay('issuer', issuerKeyPair.publicKey, `Imported ${alg}`, true);
        showStatus('issuerKeyImportStatus', `Loaded key pair (${alg})`, 'success');
        showStatus('issuerStatus', `Loaded issuer key pair from hex`, 'success');
      } catch (error) {
        showStatus('issuerKeyImportStatus', 'Failed to parse key: ' + error.message, 'error');
      }
    }
    
    // Generate EDN representation of the cnf claim from a COSE public key
    function generateCnfClaimEdn(publicKey) {
      const kty = publicKey.get(1);   // Should be 2 (EC2)
      const crv = publicKey.get(-1);  // 1 = P-256, 2 = P-384
      const x = publicKey.get(-2);    // x coordinate
      const y = publicKey.get(-3);    // y coordinate
      
      const xHex = SDCWT.Hex.encode(x);
      const yHex = SDCWT.Hex.encode(y);
      
      // Get curve name for comment
      const crvName = crv === 1 ? 'P-256' : crv === 2 ? 'P-384' : `curve ${crv}`;
      
      return `/ cnf / 8: {
    / COSE_Key / 1: {
      / kty: EC2 / 1: ${kty},
      / crv: ${crvName} / -1: ${crv},
      / x / -2: h'${xHex}',
      / y / -3: h'${yHex}'
    }
  }`;
    }
    
    // Update the cnf claim in the EDN textarea when holder key changes
    function updateCnfClaimInEdn(publicKey) {
      const textarea = document.getElementById('issuerClaimsEdn');
      let edn = textarea.value;
      
      const newCnfBlock = generateCnfClaimEdn(publicKey);
      
      // Match the entire cnf claim block (multi-line format)
      // Matches: / cnf / 8: { ... } with nested braces
      const cnfRegex = /\/\s*cnf\s*\/\s*8\s*:\s*\{[\s\S]*?\/\s*COSE_Key\s*\/\s*1\s*:\s*\{[\s\S]*?\}\s*\}/;
      
      // Also try single-line format for backwards compatibility
      const cnfRegexSingleLine = /(\/\s*cnf\s*\/\s*)?8\s*:\s*\{1\s*:\s*\{[^}]+\}\s*\}/;
      
      if (cnfRegex.test(edn)) {
        // Replace existing multi-line cnf claim
        edn = edn.replace(cnfRegex, newCnfBlock);
      } else if (cnfRegexSingleLine.test(edn)) {
        // Replace existing single-line cnf claim
        edn = edn.replace(cnfRegexSingleLine, newCnfBlock);
      } else {
        // Insert cnf claim after the opening brace
        // Find the first line after { and insert before it
        const lines = edn.split('\n');
        let inserted = false;
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].trim() === '{') {
            lines.splice(i + 1, 0, '  ' + newCnfBlock + ',');
            inserted = true;
            break;
          }
        }
        if (!inserted) {
          // Fallback: just add to beginning inside the object
          edn = edn.replace('{', '{\n  ' + newCnfBlock + ',');
        } else {
          edn = lines.join('\n');
        }
      }
      
      textarea.value = edn;
    }

    async function generateWebCryptoKeyPair(namedCurve) {
      const keyPair = await crypto.subtle.generateKey(
        { name: 'ECDSA', namedCurve },
        true,
        ['sign', 'verify']
      );

      const privateJwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey);
      const publicJwk = await crypto.subtle.exportKey('jwk', keyPair.publicKey);

      return {
        privateKey: {
          d: base64urlDecode(privateJwk.d),
          x: base64urlDecode(privateJwk.x),
          y: base64urlDecode(privateJwk.y),
        },
        publicKey: {
          x: base64urlDecode(publicJwk.x),
          y: base64urlDecode(publicJwk.y),
        },
      };
    }

    function createCoseKeyMap(key, algorithm, includePrivate) {
      // COSE Key parameters
      const kty = 2;  // EC2
      const crv = algorithm === 'ES384' ? 2 : 1;  // P-384 = 2, P-256 = 1
      
      const coseKey = new Map();
      coseKey.set(1, kty);   // kty
      coseKey.set(-1, crv);  // crv
      coseKey.set(-2, key.x); // x
      coseKey.set(-3, key.y); // y
      if (includePrivate && key.d) {
        coseKey.set(-4, key.d); // d
      }
      return coseKey;
    }

    function base64urlDecode(str) {
      const base64 = str.replace(/-/g, '+').replace(/_/g, '/');
      const pad = base64.length % 4;
      const padded = pad ? base64 + '='.repeat(4 - pad) : base64;
      const binary = atob(padded);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }

    // ==========================================================================
    // Claims Transformation
    // ==========================================================================
    
    // ==========================================================================
    // EDN Parser - Parse EDN notation into CBOR-compatible structures
    // ==========================================================================
    // EDN Parser - use library implementation
    // ==========================================================================
    
    function parseEdn(ednString) {
      return SDCWT.EDN.parse(ednString);
    }

    function transformClaimsForIssue(parsedClaims) {
      // parsedClaims is already a Map from parseEdn
      // cnf claim should already be present in the claims
      return parsedClaims;
    }
    
    // Validate that the cnf claim in parsed claims matches the holder's loaded public key
    function validateCnfClaim(parsedClaims, holderPublicKey) {
      const cnf = parsedClaims.get(8);
      if (!cnf) {
        throw new Error('cnf claim (8) is missing from claims. Please ensure holder key is loaded.');
      }
      
      const coseKey = cnf.get(1);
      if (!coseKey) {
        throw new Error('cnf claim does not contain COSE_Key (key 1)');
      }
      
      // Compare the key parameters
      const claimKty = coseKey.get(1);
      const claimCrv = coseKey.get(-1);
      const claimX = coseKey.get(-2);
      const claimY = coseKey.get(-3);
      
      const holderKty = holderPublicKey.get(1);
      const holderCrv = holderPublicKey.get(-1);
      const holderX = holderPublicKey.get(-2);
      const holderY = holderPublicKey.get(-3);
      
      // Compare values
      if (claimKty !== holderKty) {
        throw new Error('cnf claim key type does not match holder key');
      }
      if (claimCrv !== holderCrv) {
        throw new Error('cnf claim curve does not match holder key');
      }
      
      // Compare byte arrays
      const xMatch = claimX && holderX && 
        claimX.length === holderX.length && 
        claimX.every((b, i) => b === holderX[i]);
      const yMatch = claimY && holderY && 
        claimY.length === holderY.length && 
        claimY.every((b, i) => b === holderY[i]);
      
      if (!xMatch || !yMatch) {
        throw new Error('cnf claim public key coordinates do not match loaded holder key. Please reload the holder key to update the cnf claim.');
      }
      
      return true;
    }

    function transformValue(value) {
      // This is kept for backwards compatibility but no longer needed
      // since parseEdn already creates proper CBOR Tag objects
      if (value === null || value === undefined) {
        return value;
      }

      if (Array.isArray(value)) {
        return value.map(transformValue);
      }

      if (typeof value === 'object') {
        const map = new Map();
        for (const [k, v] of Object.entries(value)) {
          map.set(k, transformValue(v));
        }
        return map;
      }

      return value;
    }

    // ==========================================================================
    // Issue SD-CWT
    // ==========================================================================
    async function issueCWT() {
      try {
        if (!issuerKeyPair) {
          throw new Error('Please load or generate an issuer key first');
        }

        if (!holderKeyPair) {
          throw new Error('Please load or generate a holder key first');
        }

        const claimsEdn = document.getElementById('issuerClaimsEdn').value;
        const parsedClaims = parseEdn(claimsEdn);
        
        // Count decoys in the claims (before they get processed)
        decoyCount = countDecoysInValue(parsedClaims);
        
        // Build array disclosure info to track which disclosures are array elements
        arrayDisclosureInfo = buildArrayDisclosureInfo(parsedClaims);
        
        // Validate that the cnf claim in EDN matches the loaded holder key
        validateCnfClaim(parsedClaims, holderKeyPair.publicKey);
        
        const claims = transformClaimsForIssue(parsedClaims);

        // Issue the SD-CWT using the issuer's algorithm
        const result = await SDCWT.Issuer.issue({
          claims,
          privateKey: issuerKeyPair.privateKey,
          algorithm: issuerAlgorithm,
        });

        issuedToken = result.token;
        disclosures = result.disclosures;

        // Display result
        document.getElementById('issuerOutput').style.display = 'block';
        document.getElementById('issuedCwtHex').textContent = SDCWT.Hex.encode(result.token);
        
        const decoyMsg = decoyCount > 0 ? ` + ${decoyCount} decoy(s)` : '';
        showStatus('issuerStatus', 
          `Issued successfully with ${issuerAlgorithm}! ${disclosures.length} disclosure(s)${decoyMsg} generated.`, 'success');

        // Auto-fill holder input
        document.getElementById('holderCwt').value = SDCWT.Hex.encode(result.token);
        updateDisclosureList();

      } catch (error) {
        showStatus('issuerStatus', 'Issue failed: ' + error.message, 'error');
        console.error(error);
      }
    }

    // Update disclosure list in holder section
    function updateDisclosureList() {
      const container = document.getElementById('disclosureList');
      container.innerHTML = '';

      if (disclosures.length === 0 && decoyCount === 0) {
        document.getElementById('disclosureSelection').style.display = 'none';
        return;
      }

      document.getElementById('disclosureSelection').style.display = 'block';

      // Show real disclosures (selectable)
      for (let index = 0; index < disclosures.length; index++) {
        const disclosure = disclosures[index];
        const decoded = SDCWT.cbor.decode(disclosure);
        // SD-CWT spec disclosure format:
        // - Named claims (map entries): [salt, value, key]
        // - Array items: [salt, value]
        const salt = decoded[0];
        const claimValue = decoded[1];
        const claimKey = decoded.length > 2 ? decoded[2] : null;
        
        // Format salt as ellided hex
        const saltHex = SDCWT.Hex.encode(salt);
        const saltDisplay = ellideHex(saltHex, 16);

        const item = document.createElement('div');
        item.className = 'disclosure-item';
        
        if (claimKey !== null) {
          // Named claim: display as key : value (salt: ...)
          item.innerHTML = `
            <input type="checkbox" id="disclosure_${index}" checked data-index="${index}">
            <span class="disclosure-key">${formatKeyPreview(claimKey)}</span>
            <span class="disclosure-sep">:</span>
            <span class="disclosure-value">${formatValuePreview(claimValue)}</span>
            <span class="disclosure-salt" title="${saltHex}">(salt: ${saltDisplay})</span>
          `;
        } else {
          // Array item: use tracked array parent info
          const arrayParent = arrayDisclosureInfo[index];
          const parentLabel = arrayParent ? `<span class="disclosure-array-parent">${arrayParent}[]</span>` : '';
          
          item.innerHTML = `
            <input type="checkbox" id="disclosure_${index}" checked data-index="${index}">
            ${parentLabel}
            <span class="disclosure-value">${formatValuePreview(claimValue)}</span>
            <span class="disclosure-salt" title="${saltHex}">(salt: ${saltDisplay})</span>
          `;
        }
        container.appendChild(item);
      }
      
      // Then, show decoys (non-selectable, visually distinct)
      if (decoyCount > 0) {
        for (let i = 0; i < decoyCount; i++) {
          const item = document.createElement('div');
          item.className = 'disclosure-item decoy-item';
          item.innerHTML = `
            <span class="decoy-icon">üé≠</span>
            <span class="decoy-label">Decoy digest #${i + 1}</span>
            <span class="decoy-hint">(hides redaction count per ¬ß10)</span>
          `;
          container.appendChild(item);
        }
      }
    }
    
    function formatKeyPreview(key) {
      if (typeof key === 'string') {
        return `"${key}"`;
      }
      return String(key);
    }

    function formatValuePreview(value) {
      if (typeof value === 'string') {
        return value.length > 30 ? `"${value.slice(0, 30)}..."` : `"${value}"`;
      }
      if (typeof value === 'number' || typeof value === 'boolean') {
        return String(value);
      }
      if (Array.isArray(value)) {
        return `[array, ${value.length} items]`;
      }
      if (value instanceof Map) {
        return `{map, ${value.size} entries}`;
      }
      return String(value);
    }

    // Count decoys (tag 61) in the EDN/parsed claims
    function countDecoysInValue(value) {
      let count = 0;
      
      if (value instanceof SDCWT.cbor.Tag) {
        if (value.tag === 61) {
          // Tag 61 is ToBeDecoy, contents is the count
          return value.contents;
        }
        // Check contents of other tags
        return countDecoysInValue(value.contents);
      }
      
      if (value instanceof Map) {
        for (const [k, v] of value) {
          count += countDecoysInValue(k);
          count += countDecoysInValue(v);
        }
      } else if (Array.isArray(value)) {
        for (const elem of value) {
          count += countDecoysInValue(elem);
        }
      }
      
      return count;
    }
    
    // Build an array that tracks array parent info for each disclosure index
    // Returns an array where each index corresponds to a disclosure index
    // Value is either null (not an array element) or the array's key path
    function buildArrayDisclosureInfo(parsedClaims) {
      const info = [];
      let disclosureIndex = 0;
      
      function processValue(value, keyPath) {
        if (value instanceof SDCWT.cbor.Tag) {
          if (value.tag === 58) {
            // This is a redacted value - it will create a disclosure
            info[disclosureIndex] = null; // Not an array element
            disclosureIndex++;
            // Process nested content for any additional disclosures
            processValue(value.contents, keyPath);
          } else if (value.tag === 61) {
            // Decoy - no disclosure
          } else {
            processValue(value.contents, keyPath);
          }
          return;
        }
        
        if (value instanceof Map) {
          for (const [k, v] of value) {
            // Check if the key is a ToBeRedacted tag
            if (k instanceof SDCWT.cbor.Tag && k.tag === 58) {
              // Key-level redaction - will create a disclosure
              const actualKey = k.contents;
              info[disclosureIndex] = null; // Not an array element
              disclosureIndex++;
              // Process the value for nested disclosures
              const newPath = keyPath ? `${keyPath}.${formatKeyPreview(actualKey)}` : formatKeyPreview(actualKey);
              processValue(v, newPath);
            } else if (k instanceof SDCWT.cbor.Tag && k.tag === 61) {
              // Decoy at key level - no disclosure
            } else {
              const newPath = keyPath ? `${keyPath}.${formatKeyPreview(k)}` : formatKeyPreview(k);
              processValue(v, newPath);
            }
          }
        } else if (Array.isArray(value)) {
          for (const elem of value) {
            if (elem instanceof SDCWT.cbor.Tag && elem.tag === 58) {
              // Array element redaction - will create a disclosure
              info[disclosureIndex] = keyPath; // This is an array element
              disclosureIndex++;
              // Process the value for nested disclosures
              processValue(elem.contents, keyPath);
            } else if (elem instanceof SDCWT.cbor.Tag && elem.tag === 61) {
              // Decoy element - no disclosure
            } else {
              processValue(elem, keyPath);
            }
          }
        }
      }
      
      processValue(parsedClaims, '');
      return info;
    }

    // ==========================================================================
    // Create Presentation (Holder)
    // ==========================================================================
    async function createPresentation() {
      try {
        if (!holderKeyPair) {
          throw new Error('Please load or generate a holder key first');
        }

        const cwtHex = document.getElementById('holderCwt').value;
        if (!cwtHex) {
          throw new Error('Please provide an SD-CWT');
        }

        const audience = document.getElementById('holderAudience').value;
        if (!audience) {
          throw new Error('Audience is required');
        }

        const nonce = document.getElementById('holderNonce').value || undefined;
        const token = SDCWT.Hex.decode(cwtHex);

        // Get selected disclosures
        const selectedDisclosures = [];
        const checkboxes = document.querySelectorAll('#disclosureList input[type="checkbox"]');
        checkboxes.forEach((cb, index) => {
          if (cb.checked && disclosures[index]) {
            selectedDisclosures.push(disclosures[index]);
          }
        });

        // Create presentation using holder's algorithm
        const presentation = await SDCWT.Holder.present({
          token,
          selectedDisclosures,
          holderPrivateKey: holderKeyPair.privateKey,
          audience,
          nonce,
          algorithm: holderAlgorithm,
        });

        // Display result
        document.getElementById('holderOutput').style.display = 'block';
        document.getElementById('presentationHex').textContent = SDCWT.Hex.encode(presentation);
        
        showStatus('holderStatus', 
          `Presentation created with ${holderAlgorithm}, ${selectedDisclosures.length} disclosure(s)`, 'success');

        // Auto-fill verifier input
        document.getElementById('verifierPresentation').value = SDCWT.Hex.encode(presentation);

      } catch (error) {
        showStatus('holderStatus', 'Presentation failed: ' + error.message, 'error');
        console.error(error);
      }
    }

    // ==========================================================================
    // Verify Presentation (Verifier)
    // ==========================================================================
    async function verifyPresentation() {
      try {
        const presentationHex = document.getElementById('verifierPresentation').value;
        if (!presentationHex) {
          throw new Error('Please provide a presentation');
        }

        const issuerPubHex = document.getElementById('issuerPublicKeyForVerifier').value;
        if (!issuerPubHex) {
          throw new Error('Please provide issuer public key (as hex-encoded COSE Key)');
        }

        const expectedAudience = document.getElementById('verifierAudience').value;
        if (!expectedAudience) {
          throw new Error('Expected audience is required');
        }

        const expectedNonce = document.getElementById('verifierNonce').value || undefined;
        
        const presentation = SDCWT.Hex.decode(presentationHex);
        
        // Parse issuer public key from hex-encoded COSE Key
        const issuerPublicKey = SDCWT.coseKeyFromHex(issuerPubHex);

        // Verify
        const result = await SDCWT.Verifier.verify({
          presentation,
          issuerPublicKey,
          expectedAudience,
          expectedNonce,
          hashAlgorithm: 'sha-256',
        });

        // Display result
        document.getElementById('verifierOutput').style.display = 'block';
        
        const ednOutput = SDCWT.formatClaims(result.claims);
        document.getElementById('verifiedClaimsEdn').innerHTML = syntaxHighlightEdn(ednOutput);
        
        showStatus('verifierStatus', 'Verification successful!', 'success');

      } catch (error) {
        showStatus('verifierStatus', 'Verification failed: ' + error.message, 'error');
        document.getElementById('verifierOutput').style.display = 'block';
        document.getElementById('verifiedClaimsEdn').innerHTML = 
          `<span style="color: var(--error-red);">Error: ${error.message}</span>`;
        console.error(error);
      }
    }

    // Syntax highlighting for EDN
    function syntaxHighlightEdn(edn) {
      // Simple token-based highlighting to avoid regex conflicts with HTML
      const lines = edn.split('\n');
      const highlighted = lines.map(line => {
        let result = '';
        let i = 0;
        
        while (i < line.length) {
          // Skip whitespace
          if (/\s/.test(line[i])) {
            result += line[i];
            i++;
            continue;
          }
          
          // EDN comment: / name /
          if (line[i] === '/' && line[i+1] === ' ') {
            const end = line.indexOf(' /', i + 2);
            if (end !== -1) {
              const comment = line.slice(i, end + 2);
              result += `<span class="comment">${escapeHtml(comment)}</span>`;
              i = end + 2;
              continue;
            }
          }
          
          // String: "..."
          if (line[i] === '"') {
            let j = i + 1;
            while (j < line.length && line[j] !== '"') {
              if (line[j] === '\\') j++; // skip escaped char
              j++;
            }
            const str = line.slice(i, j + 1);
            result += `<span class="string">${escapeHtml(str)}</span>`;
            i = j + 1;
            continue;
          }
          
          // Hex string: h'...'
          if (line[i] === 'h' && line[i+1] === "'") {
            const end = line.indexOf("'", i + 2);
            if (end !== -1) {
              const hex = line.slice(i, end + 1);
              result += `<span class="hex">${escapeHtml(hex)}</span>`;
              i = end + 1;
              continue;
            }
          }
          
          // Number or tag: digits followed by ( for tag, or standalone number
          if (/[0-9\-]/.test(line[i])) {
            let j = i;
            if (line[j] === '-') j++;
            while (j < line.length && /[0-9]/.test(line[j])) j++;
            const num = line.slice(i, j);
            
            if (line[j] === '(') {
              // It's a tag like 60(
              result += `<span class="tag">${escapeHtml(num)}</span>(`;
              i = j + 1;
            } else if (line[j] === ':') {
              // It's a key like 1:
              result += `<span class="key">${escapeHtml(num)}</span>`;
              i = j;
            } else {
              // It's a value number
              result += `<span class="number">${escapeHtml(num)}</span>`;
              i = j;
            }
            continue;
          }
          
          // Default: output escaped character
          result += escapeHtml(line[i]);
          i++;
        }
        
        return result;
      });
      
      return highlighted.join('\n');
    }
    
    function escapeHtml(str) {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }


    // Utility functions
    function showStatus(elementId, message, type) {
      const el = document.getElementById(elementId);
      el.className = 'status ' + type;
      el.textContent = message;
      el.style.display = 'block';
    }

    function copyToClipboard(elementId) {
      const text = document.getElementById(elementId).textContent;
      navigator.clipboard.writeText(text).then(() => {
        // Brief visual feedback
        const btn = document.querySelector(`#${elementId}`).parentElement.querySelector('.copy-btn');
        const originalText = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = originalText, 1500);
      });
    }

    // ==========================================================================
    // Step Workflow Navigation
    // ==========================================================================
    let currentStep = 1;
    const stepCompleted = { 1: false, 2: false, 3: false, 4: false, 5: false };

    function updateStepUI() {
      // Update progress bar steps
      document.querySelectorAll('.progress-step').forEach(el => {
        const step = parseInt(el.dataset.step);
        el.classList.remove('active', 'completed', 'disabled');
        
        if (step === currentStep) {
          el.classList.add('active');
        } else if (stepCompleted[step]) {
          el.classList.add('completed');
        } else if (step < currentStep || canAccessStep(step)) {
          // Accessible but not current
        } else {
          el.classList.add('disabled');
        }
      });

      // Update connectors
      const connectors = document.querySelectorAll('.step-connector');
      connectors.forEach((connector, index) => {
        const stepNum = index + 1; // Connector after step 1, 2, 3, 4
        connector.classList.remove('completed');
        if (stepCompleted[stepNum]) {
          connector.classList.add('completed');
        }
      });

      // Update step sections
      document.querySelectorAll('.step-section').forEach(el => {
        const step = parseInt(el.dataset.step);
        el.classList.remove('active', 'completed', 'locked', 'expanded');
        
        if (step === currentStep) {
          el.classList.add('active', 'expanded');
        } else if (stepCompleted[step]) {
          el.classList.add('completed');
        } else if (!canAccessStep(step)) {
          el.classList.add('locked');
        }
      });

      // Update status labels
      for (let i = 1; i <= 5; i++) {
        const statusEl = document.getElementById(`step${i}Status`);
        if (statusEl) {
          if (stepCompleted[i]) {
            statusEl.textContent = 'Complete';
          } else if (i === currentStep) {
            statusEl.textContent = 'In Progress';
          } else if (canAccessStep(i)) {
            statusEl.textContent = 'Ready';
          } else {
            statusEl.textContent = 'Locked';
          }
        }
      }
    }

    function canAccessStep(step) {
      if (step === 1) return true;
      // Each step requires the previous step to be completed
      return stepCompleted[step - 1];
    }

    function goToStep(step) {
      if (!canAccessStep(step)) return;
      currentStep = step;
      updateStepUI();
      
      // Scroll to the step
      const stepEl = document.getElementById(`step${step}`);
      if (stepEl) {
        stepEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    // Initialize with spec keys pre-loaded
    function quickStart() {
      // Pre-load spec keys so they're displayed
      loadSpecHolderKey();
      loadSpecIssuerKey();
      
      // Start at step 1
      currentStep = 1;
      updateStepUI();
    }

    function toggleStep(step) {
      if (!canAccessStep(step)) return;
      
      const stepEl = document.getElementById(`step${step}`);
      if (stepEl) {
        if (stepEl.classList.contains('expanded')) {
          stepEl.classList.remove('expanded');
        } else {
          // Collapse others and expand this one
          document.querySelectorAll('.step-section').forEach(el => {
            el.classList.remove('expanded');
          });
          stepEl.classList.add('expanded');
          currentStep = step;
          updateStepUI();
        }
      }
    }

    function completeStep(step) {
      stepCompleted[step] = true;
      
      // Auto-advance to next step
      if (step < 5) {
        currentStep = step + 1;
      }
      
      updateStepUI();
      
      // Scroll to next step
      if (step < 5) {
        setTimeout(() => {
          const nextStepEl = document.getElementById(`step${step + 1}`);
          if (nextStepEl) {
            nextStepEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 100);
      }
    }

    function resetWorkflow() {
      currentStep = 1;
      for (let i = 1; i <= 5; i++) {
        stepCompleted[i] = false;
      }
      
      // Reset UI state
      issuerKeyPair = null;
      holderKeyPair = null;
      issuedToken = null;
      disclosures = [];
      
      document.getElementById('holderKeyEdnDisplay').innerHTML = '<span class="edn-placeholder">Key will be displayed here after loading</span>';
      document.getElementById('holderPrivateKeyWarning').style.display = 'none';
      document.getElementById('issuerKeyEdnDisplay').innerHTML = '<span class="edn-placeholder">Key will be displayed here after loading</span>';
      document.getElementById('issuerPrivateKeyWarning').style.display = 'none';
      document.getElementById('issuerOutput').style.display = 'none';
      document.getElementById('holderOutput').style.display = 'none';
      document.getElementById('verifierOutput').style.display = 'none';
      document.getElementById('disclosureSelection').style.display = 'none';
      
      updateStepUI();
      goToStep(1);
    }

    // Update key loading functions to enable step progression
    const originalLoadSpecHolderKey = loadSpecHolderKey;
    loadSpecHolderKey = function() {
      originalLoadSpecHolderKey();
      document.getElementById('step1Next').disabled = false;
    };

    const originalGenerateHolderKey = generateHolderKey;
    generateHolderKey = async function() {
      await originalGenerateHolderKey();
      document.getElementById('step1Next').disabled = false;
    };

    const originalLoadSpecIssuerKey = loadSpecIssuerKey;
    loadSpecIssuerKey = function() {
      originalLoadSpecIssuerKey();
      document.getElementById('step2Next').disabled = false;
    };

    const originalGenerateIssuerKey = generateIssuerKey;
    generateIssuerKey = async function() {
      await originalGenerateIssuerKey();
      document.getElementById('step2Next').disabled = false;
    };

    // Update issueCWT to enable step progression
    const originalIssueCWT = issueCWT;
    issueCWT = async function() {
      await originalIssueCWT();
      if (issuedToken) {
        document.getElementById('step3Next').disabled = false;
      }
    };

    // Update createPresentation to enable step progression
    const originalCreatePresentation = createPresentation;
    createPresentation = async function() {
      await originalCreatePresentation();
      const presentationHex = document.getElementById('presentationHex').textContent;
      if (presentationHex) {
        document.getElementById('step4Next').disabled = false;
      }
    };

    // ==========================================================================
    // Key management functions (update key without auto-advancing)
    // ==========================================================================
    
    async function generateHolderKeyOnly() {
      await generateHolderKey();
    }
    
    function loadHolderKeyFromHexOnly() {
      loadHolderKeyFromHex();
    }
    
    async function generateIssuerKeyOnly() {
      await generateIssuerKey();
    }
    
    function loadIssuerKeyFromHexOnly() {
      loadIssuerKeyFromHex();
    }
    
    async function issueCWTAndContinue() {
      await issueCWT();
      if (issuedToken) {
        completeStep(3);
      }
    }
    
    async function createPresentationAndContinue() {
      await createPresentation();
      const presentationHex = document.getElementById('presentationHex').textContent;
      if (presentationHex) {
        // Copy presentation hex to verify step display
        document.getElementById('presentedCwtHex').textContent = presentationHex;
        completeStep(4);
      }
    }
    
    async function verifyPresentationAndFinish() {
      await verifyPresentation();
      const verifierOutput = document.getElementById('verifierOutput');
      if (verifierOutput.style.display !== 'none') {
        stepCompleted[5] = true;
        updateStepUI();
      }
    }

    // ==========================================================================
    // Initialize
    // ==========================================================================
    window.addEventListener('DOMContentLoaded', () => {
      // Auto-load spec keys and start at Issue step
      quickStart();
      console.log('SD-CWT Playground ready with spec keys loaded.');
    });
  </script>
</body>
</html>

