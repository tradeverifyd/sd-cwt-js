{
  "version": 3,
  "sources": ["../../src/browser.js", "../../src/buffer-shim.js", "../../node_modules/cbor2/lib/index.js", "../../node_modules/cbor2/lib/constants.js", "../../node_modules/cbor2/lib/tag.js", "../../node_modules/cbor2/lib/box.js", "../../node_modules/cbor2/lib/utils.js", "../../node_modules/cbor2/lib/typeEncoderMap.js", "../../node_modules/cbor2/lib/sorts.js", "../../node_modules/cbor2/lib/writer.js", "../../node_modules/cbor2/lib/float.js", "../../node_modules/@cto.af/wtf8/lib/errors.js", "../../node_modules/@cto.af/wtf8/lib/const.js", "../../node_modules/@cto.af/wtf8/lib/decode.js", "../../node_modules/@cto.af/wtf8/lib/encode.js", "../../node_modules/cbor2/lib/encoder.js", "../../node_modules/cbor2/lib/options.js", "../../node_modules/cbor2/lib/simple.js", "../../node_modules/cbor2/lib/decodeStream.js", "../../node_modules/cbor2/lib/container.js", "../../node_modules/cbor2/lib/diagnostic.js", "../../node_modules/cbor2/lib/comment.js", "../../node_modules/cbor2/lib/types.js", "../../node_modules/cbor2/lib/version.js", "../../node_modules/cbor2/lib/decoder.js", "../../src/cose-sign1.js", "../../src/crypto-browser.js", "../../src/cose/sign1.js", "../../src/sd-cwt.js", "../../src/api.js"],
  "sourcesContent": ["/**\n * SD-CWT Browser Entry Point\n * \n * This module exports all SD-CWT functionality for browser use.\n * Built with esbuild and exposed as window.SDCWT\n */\n\n// Re-export everything from api.js\nexport * from './api.js';\n\n// Re-export low-level utilities\nexport * as sdCwt from './sd-cwt.js';\nexport * as coseSign1 from './cose-sign1.js';\n\n// Re-export cbor2 for encoding/decoding\nimport * as cbor from 'cbor2';\nexport { cbor };\n\n// Import Buffer for type checking (will use the shim in browser)\nimport { Buffer } from './buffer-shim.js';\n\n/**\n * Hex encoding utilities for browser display\n */\nexport const Hex = {\n  /**\n   * Encode bytes to hex string\n   * @param {Uint8Array|Buffer} bytes \n   * @returns {string}\n   */\n  encode(bytes) {\n    if (!bytes) return '';\n    const arr = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);\n    return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');\n  },\n\n  /**\n   * Decode hex string to Uint8Array\n   * @param {string} hex \n   * @returns {Uint8Array}\n   */\n  decode(hex) {\n    if (!hex) return new Uint8Array(0);\n    const clean = hex.replace(/\\s/g, '');\n    const bytes = new Uint8Array(clean.length / 2);\n    for (let i = 0; i < bytes.length; i++) {\n      bytes[i] = parseInt(clean.substr(i * 2, 2), 16);\n    }\n    return bytes;\n  },\n};\n\n/**\n * EDN (Extended Diagnostic Notation) utilities for CBOR display\n */\nexport const EDN = {\n  /**\n   * Convert a JavaScript value to EDN string\n   * @param {any} value \n   * @param {number} indent \n   * @returns {string}\n   */\n  stringify(value, indent = 0) {\n    return ednStringify(value, indent);\n  },\n};\n\n/**\n * Internal EDN stringifier\n */\nfunction ednStringify(value, indent = 0, depth = 0) {\n  const pad = '  '.repeat(depth);\n  const pad1 = '  '.repeat(depth + 1);\n\n  if (value === null) {\n    return 'null';\n  }\n\n  if (value === undefined) {\n    return 'undefined';\n  }\n\n  if (typeof value === 'boolean') {\n    return value ? 'true' : 'false';\n  }\n\n  if (typeof value === 'number') {\n    return String(value);\n  }\n\n  if (typeof value === 'string') {\n    return JSON.stringify(value);\n  }\n\n  if (value instanceof Uint8Array || Buffer.isBuffer(value)) {\n    const hex = Hex.encode(value);\n    if (hex.length <= 64) {\n      return `h'${hex}'`;\n    }\n    // Multi-line for long hex\n    const lines = [];\n    for (let i = 0; i < hex.length; i += 64) {\n      lines.push(hex.slice(i, i + 64));\n    }\n    return `h'${lines.join('\\n' + pad1)}'`;\n  }\n\n  if (value instanceof cbor.Tag) {\n    const tagContent = ednStringify(value.contents, indent, depth);\n    return `${value.tag}(${tagContent})`;\n  }\n\n  // Check for CBOR simple value\n  if (value && typeof value === 'object' && value.type === 'simple') {\n    return `simple(${value.value})`;\n  }\n\n  if (value instanceof Map) {\n    if (value.size === 0) {\n      return '{}';\n    }\n    const entries = [];\n    for (const [k, v] of value) {\n      const keyStr = ednStringify(k, indent, depth + 1);\n      const valStr = ednStringify(v, indent, depth + 1);\n      entries.push(`${pad1}${keyStr}: ${valStr}`);\n    }\n    return `{\\n${entries.join(',\\n')}\\n${pad}}`;\n  }\n\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return '[]';\n    }\n    const items = value.map(v => `${pad1}${ednStringify(v, indent, depth + 1)}`);\n    return `[\\n${items.join(',\\n')}\\n${pad}]`;\n  }\n\n  if (typeof value === 'object') {\n    const keys = Object.keys(value);\n    if (keys.length === 0) {\n      return '{}';\n    }\n    const entries = keys.map(k => {\n      const valStr = ednStringify(value[k], indent, depth + 1);\n      return `${pad1}\"${k}\": ${valStr}`;\n    });\n    return `{\\n${entries.join(',\\n')}\\n${pad}}`;\n  }\n\n  return String(value);\n}\n\n// Known CWT claim names for better EDN output\nconst CWT_CLAIM_NAMES = {\n  1: 'iss',\n  2: 'sub',\n  3: 'aud',\n  4: 'exp',\n  5: 'nbf',\n  6: 'iat',\n  7: 'cti',\n  8: 'cnf',\n  39: 'cnonce',\n};\n\n/**\n * Format claims with named keys for display\n * @param {Map} claims \n * @returns {string}\n */\nexport function formatClaims(claims) {\n  const formatted = new Map();\n  for (const [key, value] of claims) {\n    const name = CWT_CLAIM_NAMES[key] || key;\n    const displayKey = typeof name === 'string' ? `/ ${name} / ${key}` : key;\n    formatted.set(displayKey, value);\n  }\n  return EDN.stringify(formatted);\n}\n\n", "/**\n * Minimal Buffer shim for browser compatibility\n * \n * Provides the subset of Buffer functionality needed by sd-cwt\n */\n\nclass BufferShim extends Uint8Array {\n  constructor(input, byteOffsetOrEncoding, byteLength) {\n    // Handle the 3-argument case: new BufferShim(arrayBuffer, byteOffset, byteLength)\n    if (input instanceof ArrayBuffer && typeof byteOffsetOrEncoding === 'number') {\n      super(input, byteOffsetOrEncoding, byteLength);\n    } else if (typeof input === 'number') {\n      super(input);\n    } else if (typeof input === 'string') {\n      const bytes = BufferShim._fromString(input, byteOffsetOrEncoding);\n      super(bytes);\n    } else if (input instanceof ArrayBuffer) {\n      super(input);\n    } else if (ArrayBuffer.isView(input)) {\n      // Create a copy of the TypedArray data\n      // Use super([...]) to pass the data directly\n      super([...new Uint8Array(input.buffer, input.byteOffset, input.byteLength)]);\n    } else if (Array.isArray(input)) {\n      super(input);\n    } else if (input && typeof input === 'object' && 'type' in input && input.type === 'Buffer') {\n      // Handle Buffer.toJSON() format: { type: 'Buffer', data: [...] }\n      super(input.data);\n    } else {\n      super(input || 0);\n    }\n  }\n\n  static _fromString(str, encoding = 'utf8') {\n    if (encoding === 'hex') {\n      const hex = str.replace(/\\s/g, '');\n      const bytes = new Uint8Array(hex.length / 2);\n      for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);\n      }\n      return bytes;\n    } else if (encoding === 'base64' || encoding === 'base64url') {\n      let base64 = str;\n      if (encoding === 'base64url') {\n        base64 = base64.replace(/-/g, '+').replace(/_/g, '/');\n        const pad = base64.length % 4;\n        if (pad) {\n          base64 += '='.repeat(4 - pad);\n        }\n      }\n      const binary = atob(base64);\n      const bytes = new Uint8Array(binary.length);\n      for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n      }\n      return bytes;\n    } else {\n      // utf8\n      return new TextEncoder().encode(str);\n    }\n  }\n\n  static from(input, encoding) {\n    if (typeof input === 'string') {\n      return new BufferShim(BufferShim._fromString(input, encoding));\n    }\n    if (input instanceof ArrayBuffer) {\n      return new BufferShim(input);\n    }\n    if (ArrayBuffer.isView(input)) {\n      // Use the constructor which now handles ArrayBufferView by copying\n      return new BufferShim(input);\n    }\n    if (Array.isArray(input)) {\n      return new BufferShim(input);\n    }\n    if (input && typeof input === 'object' && 'type' in input && input.type === 'Buffer') {\n      return new BufferShim(input.data);\n    }\n    return new BufferShim(input);\n  }\n\n  static isBuffer(obj) {\n    return obj instanceof BufferShim || \n           (obj instanceof Uint8Array && obj.constructor.name === 'Buffer');\n  }\n\n  static alloc(size, fill = 0) {\n    const buf = new BufferShim(size);\n    if (fill !== 0) {\n      buf.fill(fill);\n    }\n    return buf;\n  }\n\n  static allocUnsafe(size) {\n    return new BufferShim(size);\n  }\n\n  static concat(list, totalLength) {\n    if (totalLength === undefined) {\n      totalLength = list.reduce((acc, buf) => acc + buf.length, 0);\n    }\n    const result = new BufferShim(totalLength);\n    let offset = 0;\n    for (const buf of list) {\n      result.set(buf, offset);\n      offset += buf.length;\n    }\n    return result;\n  }\n\n  toString(encoding = 'utf8') {\n    if (encoding === 'hex') {\n      return Array.from(this).map(b => b.toString(16).padStart(2, '0')).join('');\n    } else if (encoding === 'base64') {\n      let binary = '';\n      for (let i = 0; i < this.length; i++) {\n        binary += String.fromCharCode(this[i]);\n      }\n      return btoa(binary);\n    } else if (encoding === 'base64url') {\n      let binary = '';\n      for (let i = 0; i < this.length; i++) {\n        binary += String.fromCharCode(this[i]);\n      }\n      return btoa(binary).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n    } else {\n      // utf8\n      return new TextDecoder().decode(this);\n    }\n  }\n\n  toJSON() {\n    return {\n      type: 'Buffer',\n      data: Array.from(this),\n    };\n  }\n\n  slice(start, end) {\n    return new BufferShim(this.subarray(start, end));\n  }\n\n  copy(target, targetStart = 0, sourceStart = 0, sourceEnd = this.length) {\n    const source = this.subarray(sourceStart, sourceEnd);\n    target.set(source, targetStart);\n    return source.length;\n  }\n\n  equals(other) {\n    if (this.length !== other.length) return false;\n    for (let i = 0; i < this.length; i++) {\n      if (this[i] !== other[i]) return false;\n    }\n    return true;\n  }\n\n  compare(other) {\n    const len = Math.min(this.length, other.length);\n    for (let i = 0; i < len; i++) {\n      if (this[i] < other[i]) return -1;\n      if (this[i] > other[i]) return 1;\n    }\n    if (this.length < other.length) return -1;\n    if (this.length > other.length) return 1;\n    return 0;\n  }\n\n  readUInt32BE(offset = 0) {\n    return (\n      (this[offset] << 24) |\n      (this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      this[offset + 3]\n    ) >>> 0;\n  }\n\n  writeUInt32BE(value, offset = 0) {\n    this[offset] = (value >>> 24) & 0xff;\n    this[offset + 1] = (value >>> 16) & 0xff;\n    this[offset + 2] = (value >>> 8) & 0xff;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n  }\n}\n\n// Make BufferShim inherit all Uint8Array static properties\nObject.getOwnPropertyNames(Uint8Array).forEach(prop => {\n  if (!(prop in BufferShim) && typeof Uint8Array[prop] === 'function') {\n    BufferShim[prop] = Uint8Array[prop];\n  }\n});\n\nexport const Buffer = BufferShim;\nexport default BufferShim;\n\n", "import\"./types.js\";import{version as i}from\"./version.js\";import{CBORcontainer as e}from\"./container.js\";import{DiagnosticSizes as m}from\"./options.js\";import{decode as O,decodeSequence as f,SequenceEvents as u}from\"./decoder.js\";import{diagnose as g}from\"./diagnostic.js\";import{comment as D}from\"./comment.js\";import{cdeEncodeOptions as y,defaultEncodeOptions as T,dcborEncodeOptions as b,encode as S,encodedNumber as C}from\"./encoder.js\";import{Simple as R}from\"./simple.js\";import{Tag as V}from\"./tag.js\";import{Writer as B}from\"./writer.js\";import{saveEncoded as N,saveEncodedLength as z,unbox as A,getEncoded as I}from\"./box.js\";const{cdeDecodeOptions:r,dcborDecodeOptions:n,defaultDecodeOptions:d}=e;import{TypeEncoderMap as W}from\"./typeEncoderMap.js\";export{m as DiagnosticSizes,u as SequenceEvents,R as Simple,V as Tag,W as TypeEncoderMap,B as Writer,r as cdeDecodeOptions,y as cdeEncodeOptions,D as comment,n as dcborDecodeOptions,b as dcborEncodeOptions,O as decode,f as decodeSequence,d as defaultDecodeOptions,T as defaultEncodeOptions,g as diagnose,S as encode,C as encodedNumber,I as getEncoded,N as saveEncoded,z as saveEncodedLength,A as unbox,i as version};\n", "const f={POS_INT:0,NEG_INT:1,BYTE_STRING:2,UTF8_STRING:3,ARRAY:4,MAP:5,TAG:6,SIMPLE_FLOAT:7},I={DATE_STRING:0,DATE_EPOCH:1,POS_BIGINT:2,NEG_BIGINT:3,DECIMAL_FRAC:4,BIGFLOAT:5,BASE64URL_EXPECTED:21,BASE64_EXPECTED:22,BASE16_EXPECTED:23,CBOR:24,URI:32,BASE64URL:33,BASE64:34,MIME:36,SET:258,JSON:262,WTF8:273,REGEXP:21066,SELF_DESCRIBED:55799,INVALID_16:65535,INVALID_32:4294967295,INVALID_64:0xffffffffffffffffn},o={ZERO:0,ONE:24,TWO:25,FOUR:26,EIGHT:27,INDEFINITE:31},T={FALSE:20,TRUE:21,NULL:22,UNDEFINED:23};class N{static BREAK=Symbol.for(\"github.com/hildjj/cbor2/break\");static ENCODED=Symbol.for(\"github.com/hildjj/cbor2/cbor-encoded\");static LENGTH=Symbol.for(\"github.com/hildjj/cbor2/length\")}const S={MIN:-(2n**63n),MAX:2n**64n-1n};export{S as DCBOR_INT,f as MT,o as NUMBYTES,T as SIMPLE,N as SYMS,I as TAG};\n", "class i{static#e=new Map;tag;contents;constructor(e,t=void 0){this.tag=e,this.contents=t}get noChildren(){return!!i.#e.get(this.tag)?.noChildren}static registerDecoder(e,t,n){const o=this.#e.get(e);return this.#e.set(e,t),o&&(\"comment\"in t||(t.comment=o.comment),\"noChildren\"in t||(t.noChildren=o.noChildren)),n&&!t.comment&&(t.comment=()=>`(${n})`),o}static clearDecoder(e){const t=this.#e.get(e);return this.#e.delete(e),t}static getDecoder(e){return this.#e.get(e)}static getAllDecoders(){return new Map(this.#e)}*[Symbol.iterator](){yield this.contents}push(e){return this.contents=e,1}decode(e){const t=e?.tags?.get(this.tag)??i.#e.get(this.tag);return t?t(this,e):this}comment(e,t){const n=e?.tags?.get(this.tag)??i.#e.get(this.tag);if(n?.comment)return n.comment(this,e,t)}toCBOR(){return[this.tag,this.contents]}[Symbol.for(\"nodejs.util.inspect.custom\")](e,t,n){return`${this.tag}(${n(this.contents,t)})`}}export{i as Tag};\n", "import{SYMS as i}from\"./constants.js\";import{Tag as o}from\"./tag.js\";function f(n){if(n!=null&&typeof n==\"object\")return n[i.ENCODED]}function s(n){if(n!=null&&typeof n==\"object\")return n[i.LENGTH]}function u(n,e){Object.defineProperty(n,i.ENCODED,{configurable:!0,enumerable:!1,value:e})}function l(n,e){Object.defineProperty(n,i.LENGTH,{configurable:!0,enumerable:!1,value:e})}function d(n,e){const r=Object(n);return u(r,e),r}function t(n){if(!n||typeof n!=\"object\")return n;switch(n.constructor){case BigInt:case Boolean:case Number:case String:case Symbol:return n.valueOf();case Array:return n.map(e=>t(e));case Map:{const e=t([...n.entries()]);return e.every(([r])=>typeof r==\"string\")?Object.fromEntries(e):new Map(e)}case o:return new o(t(n.tag),t(n.contents));case Object:{const e={};for(const[r,a]of Object.entries(n))e[r]=t(a);return e}}return n}export{d as box,f as getEncoded,s as getEncodedLength,u as saveEncoded,l as saveEncodedLength,t as unbox};\n", "const g=Symbol(\"CBOR_RANGES\");function c(r,n){Object.defineProperty(r,g,{configurable:!1,enumerable:!1,writable:!1,value:n})}function f(r){return r[g]}function l(r){return f(r)!==void 0}function R(r,n=0,t=r.length-1){const o=r.subarray(n,t),a=f(r);if(a){const s=[];for(const e of a)if(e[0]>=n&&e[0]+e[1]<=t){const i=[...e];i[0]-=n,s.push(i)}s.length&&c(o,s)}return o}function b(r){let n=Math.ceil(r.length/2);const t=new Uint8Array(n);n--;for(let o=r.length,a=o-2;o>=0;o=a,a-=2,n--)t[n]=parseInt(r.substring(a,o),16);return t}function A(r){return r.reduce((n,t)=>n+t.toString(16).padStart(2,\"0\"),\"\")}function d(r){const n=r.reduce((e,i)=>e+i.length,0),t=r.some(e=>l(e)),o=[],a=new Uint8Array(n);let s=0;for(const e of r){if(!(e instanceof Uint8Array))throw new TypeError(`Invalid array: ${e}`);if(a.set(e,s),t){const i=e[g]??[[0,e.length]];for(const u of i)u[0]+=s;o.push(...i)}s+=e.length}return t&&c(a,o),a}function y(r){const n=atob(r);return Uint8Array.from(n,t=>t.codePointAt(0))}const p={\"-\":\"+\",_:\"/\"};function x(r){const n=r.replace(/[_-]/g,t=>p[t]);return y(n.padEnd(Math.ceil(n.length/4)*4,\"=\"))}function h(){const r=new Uint8Array(4),n=new Uint32Array(r.buffer);return!((n[0]=1)&r[0])}function U(r){let n=\"\";for(const t of r){const o=t.codePointAt(0)?.toString(16).padStart(4,\"0\");n&&(n+=\", \"),n+=`U+${o}`}return n}export{g as CBOR_RANGES,y as base64ToBytes,x as base64UrlToBytes,f as getRanges,l as hasRanges,b as hexToU8,h as isBigEndian,c as setRanges,U as stringToHex,R as subarrayRanges,d as u8concat,A as u8toHex};\n", "class s{#e=new Map;registerEncoder(e,t){const n=this.#e.get(e);return this.#e.set(e,t),n}get(e){return this.#e.get(e)}delete(e){return this.#e.delete(e)}clear(){this.#e.clear()}}export{s as TypeEncoderMap};\n", "function f(c,d){const[u,a,n]=c,[l,s,t]=d,r=Math.min(n.length,t.length);for(let o=0;o<r;o++){const e=n[o]-t[o];if(e!==0)return e}return 0}function y(c,d){const[u,a,n]=c,[l,s,t]=d,r=n.length-t.length;if(r!==0)return r;const o=Math.min(n.length,t.length);for(let e=0;e<o;e++){const i=n[e]-t[e];if(i!==0)return i}return 0}export{f as sortCoreDeterministic,y as sortLengthFirstDeterministic};\n", "class e{static defaultOptions={chunkSize:4096};#r;#i=[];#s=null;#t=0;#a=0;constructor(t={}){if(this.#r={...e.defaultOptions,...t},this.#r.chunkSize<8)throw new RangeError(`Expected size >= 8, got ${this.#r.chunkSize}`);this.#n()}get length(){return this.#a}read(){this.#o();const t=new Uint8Array(this.#a);let i=0;for(const s of this.#i)t.set(s,i),i+=s.length;return this.#n(),t}write(t){const i=t.length;i>this.#l()?(this.#o(),i>this.#r.chunkSize?(this.#i.push(t),this.#n()):(this.#n(),this.#i[this.#i.length-1].set(t),this.#t=i)):(this.#i[this.#i.length-1].set(t,this.#t),this.#t+=i),this.#a+=i}writeUint8(t){this.#e(1),this.#s.setUint8(this.#t,t),this.#h(1)}writeUint16(t,i=!1){this.#e(2),this.#s.setUint16(this.#t,t,i),this.#h(2)}writeUint32(t,i=!1){this.#e(4),this.#s.setUint32(this.#t,t,i),this.#h(4)}writeBigUint64(t,i=!1){this.#e(8),this.#s.setBigUint64(this.#t,t,i),this.#h(8)}writeInt16(t,i=!1){this.#e(2),this.#s.setInt16(this.#t,t,i),this.#h(2)}writeInt32(t,i=!1){this.#e(4),this.#s.setInt32(this.#t,t,i),this.#h(4)}writeBigInt64(t,i=!1){this.#e(8),this.#s.setBigInt64(this.#t,t,i),this.#h(8)}writeFloat32(t,i=!1){this.#e(4),this.#s.setFloat32(this.#t,t,i),this.#h(4)}writeFloat64(t,i=!1){this.#e(8),this.#s.setFloat64(this.#t,t,i),this.#h(8)}clear(){this.#a=0,this.#i=[],this.#n()}#n(){const t=new Uint8Array(this.#r.chunkSize);this.#i.push(t),this.#t=0,this.#s=new DataView(t.buffer,t.byteOffset,t.byteLength)}#o(){if(this.#t===0){this.#i.pop();return}const t=this.#i.length-1;this.#i[t]=this.#i[t].subarray(0,this.#t),this.#t=0,this.#s=null}#l(){const t=this.#i.length-1;return this.#i[t].length-this.#t}#e(t){this.#l()<t&&(this.#o(),this.#n())}#h(t){this.#t+=t,this.#a+=t}}export{e as Writer};\n", "function o(e,n=0,t=!1){const r=e[n]&128?-1:1,f=(e[n]&124)>>2,a=(e[n]&3)<<8|e[n+1];if(f===0){if(t&&a!==0)throw new Error(`Unwanted subnormal: ${r*5960464477539063e-23*a}`);return r*5960464477539063e-23*a}else if(f===31)return a?NaN:r*(1/0);return r*2**(f-25)*(1024+a)}function s(e){const n=new DataView(new ArrayBuffer(4));n.setFloat32(0,e,!1);const t=n.getUint32(0,!1);if((t&8191)!==0)return null;let r=t>>16&32768;const f=t>>23&255,a=t&8388607;if(!(f===0&&a===0))if(f>=113&&f<=142)r+=(f-112<<10)+(a>>13);else if(f>=103&&f<113){if(a&(1<<126-f)-1)return null;r+=a+8388608>>126-f}else if(f===255)r|=31744,r|=a>>13;else return null;return r}function i(e){if(e!==0){const n=new ArrayBuffer(8),t=new DataView(n);t.setFloat64(0,e,!1);const r=t.getBigUint64(0,!1);if((r&0x7ff0000000000000n)===0n)return r&0x8000000000000000n?-0:0}return e}function l(e){switch(e.length){case 2:o(e,0,!0);break;case 4:{const n=new DataView(e.buffer,e.byteOffset,e.byteLength),t=n.getUint32(0,!1);if((t&2139095040)===0&&t&8388607)throw new Error(`Unwanted subnormal: ${n.getFloat32(0,!1)}`);break}case 8:{const n=new DataView(e.buffer,e.byteOffset,e.byteLength),t=n.getBigUint64(0,!1);if((t&0x7ff0000000000000n)===0n&&t&0x000fffffffffffn)throw new Error(`Unwanted subnormal: ${n.getFloat64(0,!1)}`);break}default:throw new TypeError(`Bad input to isSubnormal: ${e}`)}}export{l as checkSubnormal,i as flushToZero,s as halfToUint,o as parseHalf};\n", "export class DecodeError extends TypeError {\n    code = 'ERR_ENCODING_INVALID_ENCODED_DATA';\n    constructor() {\n        super('The encoded data was not valid for encoding wtf-8');\n    }\n}\nexport class InvalidEncodingError extends RangeError {\n    code = 'ERR_ENCODING_NOT_SUPPORTED';\n    constructor(label) {\n        super(`Invalid encoding: \"${label}\"`);\n    }\n}\n", "export const BOM = 0xfeff;\nexport const EMPTY = new Uint8Array(0);\nexport const MAX_HIGH_SURROGATE = 0xdbff;\nexport const MAX_LOW_SURROGATE = 0xdfff;\nexport const MIN_HIGH_SURROGATE = 0xd800;\nexport const MIN_LOW_SURROGATE = 0xdc00;\nexport const REPLACEMENT = 0xfffd;\nexport const WTF8 = 'wtf-8';\n", "import { BOM, EMPTY, MIN_HIGH_SURROGATE, MIN_LOW_SURROGATE, REPLACEMENT, WTF8, } from './const.js';\nimport { DecodeError, InvalidEncodingError } from './errors.js';\nfunction isArrayBufferView(input) {\n    return (input &&\n        !(input instanceof ArrayBuffer) &&\n        input.buffer instanceof ArrayBuffer);\n}\nfunction getUint8(input) {\n    if (!input) {\n        return EMPTY;\n    }\n    if (input instanceof Uint8Array) {\n        return input;\n    }\n    if (isArrayBufferView(input)) {\n        return new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n    }\n    return new Uint8Array(input);\n}\nconst REMAINDER = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    -1,\n    -1,\n    -1,\n    -1,\n    1,\n    1,\n    2,\n    3,\n];\nexport class Wtf8Decoder {\n    static DEFAULT_BUFFERSIZE = 0x1000;\n    encoding = WTF8;\n    fatal;\n    ignoreBOM;\n    bufferSize;\n    #left = 0;\n    #cur = 0;\n    #pending = 0;\n    #first = true;\n    #buf;\n    constructor(label = 'wtf8', options = undefined) {\n        if (label.toLowerCase().replace('-', '') !== 'wtf8') {\n            throw new InvalidEncodingError(label);\n        }\n        this.fatal = Boolean(options?.fatal);\n        this.ignoreBOM = Boolean(options?.ignoreBOM);\n        this.bufferSize = Math.floor(options?.bufferSize ?? Wtf8Decoder.DEFAULT_BUFFERSIZE);\n        if (isNaN(this.bufferSize) || (this.bufferSize < 1)) {\n            throw new RangeError(`Invalid buffer size: ${options?.bufferSize}`);\n        }\n        this.#buf = new Uint16Array(this.bufferSize);\n    }\n    decode(input, options) {\n        const streaming = Boolean(options?.stream);\n        const bytes = getUint8(input);\n        const res = [];\n        const out = this.#buf;\n        const maxSize = this.bufferSize - 3;\n        let pos = 0;\n        const fatal = () => {\n            this.#cur = 0;\n            this.#left = 0;\n            this.#pending = 0;\n            if (this.fatal) {\n                throw new DecodeError();\n            }\n            out[pos++] = REPLACEMENT;\n        };\n        const fatals = () => {\n            const p = this.#pending;\n            for (let i = 0; i < p; i++) {\n                fatal();\n            }\n        };\n        const oneByte = (b) => {\n            if (this.#left === 0) {\n                const n = REMAINDER[b >> 4];\n                switch (n) {\n                    case -1:\n                        fatal();\n                        break;\n                    case 0:\n                        out[pos++] = b;\n                        break;\n                    case 1:\n                        this.#cur = b & 0x1f;\n                        if ((this.#cur & 0x1e) === 0) {\n                            fatal();\n                        }\n                        else {\n                            this.#left = 1;\n                            this.#pending = 1;\n                        }\n                        break;\n                    case 2:\n                        this.#cur = b & 0x0f;\n                        this.#left = 2;\n                        this.#pending = 1;\n                        break;\n                    case 3:\n                        if (b & 0x08) {\n                            fatal();\n                        }\n                        else {\n                            this.#cur = b & 0x07;\n                            this.#left = 3;\n                            this.#pending = 1;\n                        }\n                        break;\n                }\n            }\n            else {\n                if ((b & 0xc0) !== 0x80) {\n                    fatals();\n                    return oneByte(b);\n                }\n                if ((this.#pending === 1) &&\n                    (this.#left === 2) &&\n                    (this.#cur === 0) &&\n                    ((b & 0x20) === 0)) {\n                    fatals();\n                    return oneByte(b);\n                }\n                if ((this.#left === 3) && (this.#cur === 0) && ((b & 0x30) === 0)) {\n                    fatals();\n                    return oneByte(b);\n                }\n                this.#cur = (this.#cur << 6) | (b & 0x3f);\n                this.#pending++;\n                if (--this.#left === 0) {\n                    if (this.ignoreBOM || !this.#first || (this.#cur !== BOM)) {\n                        if (this.#cur < 0x10000) {\n                            out[pos++] = this.#cur;\n                        }\n                        else {\n                            const cp = this.#cur - 0x10000;\n                            out[pos++] = ((cp >>> 10) & 0x3ff) | MIN_HIGH_SURROGATE;\n                            out[pos++] = (cp & 0x3ff) | MIN_LOW_SURROGATE;\n                        }\n                    }\n                    this.#cur = 0;\n                    this.#pending = 0;\n                    this.#first = false;\n                }\n            }\n        };\n        for (const b of bytes) {\n            if (pos >= maxSize) {\n                res.push(String.fromCharCode.apply(null, out.subarray(0, pos)));\n                pos = 0;\n            }\n            oneByte(b);\n        }\n        if (!streaming) {\n            this.#first = true;\n            if (this.#cur || this.#left) {\n                fatals();\n            }\n        }\n        if (pos > 0) {\n            res.push(String.fromCharCode.apply(null, out.subarray(0, pos)));\n        }\n        return res.join('');\n    }\n}\n", "import { EMPTY, WTF8 } from './const.js';\nfunction utf8length(str) {\n    let len = 0;\n    for (const s of str) {\n        const cp = s.codePointAt(0);\n        if (cp < 0x80) {\n            len++;\n        }\n        else if (cp < 0x800) {\n            len += 2;\n        }\n        else if (cp < 0x10000) {\n            len += 3;\n        }\n        else {\n            len += 4;\n        }\n    }\n    return len;\n}\nexport class Wtf8Encoder {\n    encoding = WTF8;\n    encode(input) {\n        if (!input) {\n            return EMPTY;\n        }\n        const buf = new Uint8Array(utf8length(String(input)));\n        this.encodeInto(input, buf);\n        return buf;\n    }\n    encodeInto(source, destination) {\n        const str = String(source);\n        const len = str.length;\n        const outLen = destination.length;\n        let written = 0;\n        let read = 0;\n        for (read = 0; read < len; read++) {\n            const c = str.codePointAt(read);\n            if (c < 0x80) {\n                if (written >= outLen) {\n                    break;\n                }\n                destination[written++] = c;\n            }\n            else if (c < 0x800) {\n                if (written >= outLen - 1) {\n                    break;\n                }\n                destination[written++] = 0xc0 | (c >> 6);\n                destination[written++] = 0x80 | (c & 0x3f);\n            }\n            else if (c < 0x10000) {\n                if (written >= outLen - 2) {\n                    break;\n                }\n                destination[written++] = 0xe0 | (c >> 12);\n                destination[written++] = 0x80 | ((c >> 6) & 0x3f);\n                destination[written++] = 0x80 | (c & 0x3f);\n            }\n            else {\n                if (written >= outLen - 3) {\n                    break;\n                }\n                destination[written++] = 0xf0 | (c >> 18);\n                destination[written++] = 0x80 | ((c >> 12) & 0x3f);\n                destination[written++] = 0x80 | ((c >> 6) & 0x3f);\n                destination[written++] = 0x80 | (c & 0x3f);\n                read++;\n            }\n        }\n        return {\n            read,\n            written,\n        };\n    }\n}\n", "import{TypeEncoderMap as L}from\"./typeEncoderMap.js\";import{DCBOR_INT as x,MT as f,NUMBYTES as d,SIMPLE as l,SYMS as m,TAG as I}from\"./constants.js\";import{sortCoreDeterministic as _}from\"./sorts.js\";import{Writer as O}from\"./writer.js\";import{box as G,getEncodedLength as C}from\"./box.js\";import{flushToZero as D,halfToUint as S}from\"./float.js\";import{Wtf8Encoder as M}from\"@cto.af/wtf8\";import{hexToU8 as W}from\"./utils.js\";const{ENCODED:se}=m,U=f.SIMPLE_FLOAT<<5|d.TWO,h=f.SIMPLE_FLOAT<<5|d.FOUR,B=f.SIMPLE_FLOAT<<5|d.EIGHT,j=f.SIMPLE_FLOAT<<5|l.TRUE,P=f.SIMPLE_FLOAT<<5|l.FALSE,$=f.SIMPLE_FLOAT<<5|l.UNDEFINED,q=f.SIMPLE_FLOAT<<5|l.NULL,z=new TextEncoder,K=new M,k={...O.defaultOptions,avoidInts:!1,cde:!1,collapseBigInts:!0,dcbor:!1,float64:!1,flushToZero:!1,forceEndian:null,ignoreOriginalEncoding:!1,largeNegativeAsBigInt:!1,reduceUnsafeNumbers:!1,rejectBigInts:!1,rejectCustomSimples:!1,rejectDuplicateKeys:!1,rejectFloats:!1,rejectUndefined:!1,simplifyNegativeZero:!1,sortKeys:null,stringNormalization:null,types:null,wtf8:!1},F={cde:!0,ignoreOriginalEncoding:!0,sortKeys:_},H={...F,dcbor:!0,largeNegativeAsBigInt:!0,reduceUnsafeNumbers:!0,rejectCustomSimples:!0,rejectDuplicateKeys:!0,rejectUndefined:!0,simplifyNegativeZero:!0,stringNormalization:\"NFC\"};function y(e){const n=e<0;return typeof e==\"bigint\"?[n?-e-1n:e,n]:[n?-e-1:e,n]}function T(e,n,t){if(t.rejectFloats)throw new Error(`Attempt to encode an unwanted floating point number: ${e}`);if(isNaN(e))n.writeUint8(U),n.writeUint16(32256);else if(!t.float64&&Math.fround(e)===e){const r=S(e);r===null?(n.writeUint8(h),n.writeFloat32(e)):(n.writeUint8(U),n.writeUint16(r))}else n.writeUint8(B),n.writeFloat64(e)}function a(e,n,t){const[r,i]=y(e);if(i&&t)throw new TypeError(`Negative size: ${e}`);t??=i?f.NEG_INT:f.POS_INT,t<<=5,r<24?n.writeUint8(t|r):r<=255?(n.writeUint8(t|d.ONE),n.writeUint8(r)):r<=65535?(n.writeUint8(t|d.TWO),n.writeUint16(r)):r<=4294967295?(n.writeUint8(t|d.FOUR),n.writeUint32(r)):(n.writeUint8(t|d.EIGHT),n.writeBigUint64(BigInt(r)))}function p(e,n,t){typeof e==\"number\"?a(e,n,f.TAG):typeof e==\"object\"&&!t.ignoreOriginalEncoding&&m.ENCODED in e?n.write(e[m.ENCODED]):e<=Number.MAX_SAFE_INTEGER?a(Number(e),n,f.TAG):(n.writeUint8(f.TAG<<5|d.EIGHT),n.writeBigUint64(BigInt(e)))}function N(e,n,t){const[r,i]=y(e);if(t.collapseBigInts&&(!t.largeNegativeAsBigInt||e>=-0x8000000000000000n)){if(r<=0xffffffffn){a(Number(e),n);return}if(r<=0xffffffffffffffffn){const E=(i?f.NEG_INT:f.POS_INT)<<5;n.writeUint8(E|d.EIGHT),n.writeBigUint64(r);return}}if(t.rejectBigInts)throw new Error(`Attempt to encode unwanted bigint: ${e}`);const o=i?I.NEG_BIGINT:I.POS_BIGINT,c=r.toString(16),s=c.length%2?\"0\":\"\";p(o,n,t);const u=W(s+c);a(u.length,n,f.BYTE_STRING),n.write(u)}function Y(e,n,t){t.flushToZero&&(e=D(e)),Object.is(e,-0)?t.simplifyNegativeZero?t.avoidInts?T(0,n,t):a(0,n):T(e,n,t):!t.avoidInts&&Number.isSafeInteger(e)?a(e,n):t.reduceUnsafeNumbers&&Math.floor(e)===e&&e>=x.MIN&&e<=x.MAX?N(BigInt(e),n,t):T(e,n,t)}function Z(e,n,t){const r=t.stringNormalization?e.normalize(t.stringNormalization):e;if(t.wtf8&&!e.isWellFormed()){const i=K.encode(r);p(I.WTF8,n,t),a(i.length,n,f.BYTE_STRING),n.write(i)}else{const i=z.encode(r);a(i.length,n,f.UTF8_STRING),n.write(i)}}function J(e,n,t){const r=e;R(r,r.length,f.ARRAY,n,t);for(const i of r)g(i,n,t)}function V(e,n){a(e.length,n,f.BYTE_STRING),n.write(e)}const b=new L;b.registerEncoder(Array,J),b.registerEncoder(Uint8Array,V);function ce(e,n){return b.registerEncoder(e,n)}function ue(e){const n=b.get(e);return b.delete(e),n}function R(e,n,t,r,i){const o=C(e);o&&!i.ignoreOriginalEncoding?r.write(o):a(n,r,t)}function X(e,n,t){if(e===null){n.writeUint8(q);return}if(!t.ignoreOriginalEncoding&&m.ENCODED in e){n.write(e[m.ENCODED]);return}const r=e.constructor;if(r){const o=t.types?.get(r)??b.get(r);if(o){const c=o(e,n,t);if(c!==void 0){if(!Array.isArray(c)||c.length!==2)throw new Error(\"Invalid encoder return value\");(typeof c[0]==\"bigint\"||isFinite(Number(c[0])))&&p(c[0],n,t),g(c[1],n,t)}return}}if(typeof e.toCBOR==\"function\"){const o=e.toCBOR(n,t);o&&((typeof o[0]==\"bigint\"||isFinite(Number(o[0])))&&p(o[0],n,t),g(o[1],n,t));return}if(typeof e.toJSON==\"function\"){g(e.toJSON(),n,t);return}const i=Object.entries(e).map(o=>[o[0],o[1],Q(o[0],t)]);t.sortKeys&&i.sort(t.sortKeys),R(e,i.length,f.MAP,n,t);for(const[o,c,s]of i)n.write(s),g(c,n,t)}function g(e,n,t){switch(typeof e){case\"number\":Y(e,n,t);break;case\"bigint\":N(e,n,t);break;case\"string\":Z(e,n,t);break;case\"boolean\":n.writeUint8(e?j:P);break;case\"undefined\":if(t.rejectUndefined)throw new Error(\"Attempt to encode unwanted undefined.\");n.writeUint8($);break;case\"object\":X(e,n,t);break;case\"symbol\":throw new TypeError(`Unknown symbol: ${e.toString()}`);default:throw new TypeError(`Unknown type: ${typeof e}, ${String(e)}`)}}function Q(e,n={}){const t={...k};n.dcbor?Object.assign(t,H):n.cde&&Object.assign(t,F),Object.assign(t,n);const r=new O(t);return g(e,r,t),r.read()}function de(e,n,t=f.POS_INT){n||(n=\"f\");const r={...k,collapseBigInts:!1,chunkSize:10,simplifyNegativeZero:!1},i=new O(r),o=Number(e);function c(s){if(Object.is(e,-0))throw new Error(\"Invalid integer: -0\");const[u,E]=y(e);if(E&&t!==f.POS_INT)throw new Error(\"Invalid major type combination\");const w=typeof s==\"number\"&&isFinite(s);if(w&&!Number.isSafeInteger(o))throw new TypeError(`Unsafe number for ${n}: ${e}`);if(u>s)throw new TypeError(`Undersized encoding ${n} for: ${e}`);const A=(E?f.NEG_INT:t)<<5;return w?[A,Number(u)]:[A,u]}switch(n){case\"bigint\":if(Object.is(e,-0))throw new TypeError(\"Invalid bigint: -0\");e=BigInt(e),N(e,i,r);break;case\"f\":T(o,i,r);break;case\"f16\":{const s=S(o);if(s===null)throw new TypeError(`Invalid f16: ${e}`);i.writeUint8(U),i.writeUint16(s);break}case\"f32\":if(!isNaN(o)&&Math.fround(o)!==o)throw new TypeError(`Invalid f32: ${e}`);i.writeUint8(h),i.writeFloat32(o);break;case\"f64\":i.writeUint8(B),i.writeFloat64(o);break;case\"i\":if(Object.is(e,-0))throw new Error(\"Invalid integer: -0\");if(Number.isSafeInteger(o))a(o,i,e<0?void 0:t);else{const[s,u]=c(1/0);u>0xffffffffffffffffn?(e=BigInt(e),N(e,i,r)):(i.writeUint8(s|d.EIGHT),i.writeBigUint64(BigInt(u)))}break;case\"i0\":{const[s,u]=c(23);i.writeUint8(s|u);break}case\"i8\":{const[s,u]=c(255);i.writeUint8(s|d.ONE),i.writeUint8(u);break}case\"i16\":{const[s,u]=c(65535);i.writeUint8(s|d.TWO),i.writeUint16(u);break}case\"i32\":{const[s,u]=c(4294967295);i.writeUint8(s|d.FOUR),i.writeUint32(u);break}case\"i64\":{const[s,u]=c(0xffffffffffffffffn);i.writeUint8(s|d.EIGHT),i.writeBigUint64(BigInt(u));break}default:throw new TypeError(`Invalid number encoding: \"${n}\"`)}return G(e,i.read())}export{se as ENCODED,F as cdeEncodeOptions,ue as clearEncoder,H as dcborEncodeOptions,k as defaultEncodeOptions,Q as encode,de as encodedNumber,ce as registerEncoder,J as writeArray,N as writeBigInt,T as writeFloat,a as writeInt,R as writeLength,Y as writeNumber,Z as writeString,p as writeTag,V as writeUint8Array,g as writeUnknown};\n", "var o=(e=>(e[e.NEVER=-1]=\"NEVER\",e[e.PREFERRED=0]=\"PREFERRED\",e[e.ALWAYS=1]=\"ALWAYS\",e))(o||{});export{o as DiagnosticSizes};\n", "import{MT as u,SIMPLE as n}from\"./constants.js\";import{writeInt as o}from\"./encoder.js\";class t{static KnownSimple=new Map([[n.FALSE,!1],[n.TRUE,!0],[n.NULL,null],[n.UNDEFINED,void 0]]);value;constructor(e){this.value=e}static create(e){return t.KnownSimple.has(e)?t.KnownSimple.get(e):new t(e)}toCBOR(e,i){if(i.rejectCustomSimples)throw new Error(`Cannot encode non-standard Simple value: ${this.value}`);o(this.value,e,u.SIMPLE_FLOAT)}toString(){return`simple(${this.value})`}decode(){return t.KnownSimple.has(this.value)?t.KnownSimple.get(this.value):this}[Symbol.for(\"nodejs.util.inspect.custom\")](e,i,r){return`simple(${r(this.value,i)})`}}export{t as Simple};\n", "import{MT as s,NUMBYTES as l,SYMS as d}from\"./constants.js\";import{base64ToBytes as m,hexToU8 as b,subarrayRanges as u}from\"./utils.js\";import{Simple as g}from\"./simple.js\";import{parseHalf as E}from\"./float.js\";const p=new TextDecoder(\"utf8\",{fatal:!0,ignoreBOM:!0});class y{static defaultOptions={maxDepth:1024,encoding:\"hex\",requirePreferred:!1};#t;#r;#e=0;#i;constructor(t,r){if(this.#i={...y.defaultOptions,...r},typeof t==\"string\")switch(this.#i.encoding){case\"hex\":this.#t=b(t);break;case\"base64\":this.#t=m(t);break;default:throw new TypeError(`Encoding not implemented: \"${this.#i.encoding}\"`)}else this.#t=t;this.#r=new DataView(this.#t.buffer,this.#t.byteOffset,this.#t.byteLength)}toHere(t){return u(this.#t,t,this.#e)}*[Symbol.iterator](){if(yield*this.#n(0),this.#e!==this.#t.length)throw new Error(\"Extra data in input\")}*seq(){for(;this.#e<this.#t.length;)yield*this.#n(0)}*#n(t){if(t++>this.#i.maxDepth)throw new Error(`Maximum depth ${this.#i.maxDepth} exceeded`);const r=this.#e,c=this.#r.getUint8(this.#e++),i=c>>5,n=c&31;let e=n,f=!1,a=0;switch(n){case l.ONE:if(a=1,e=this.#r.getUint8(this.#e),i===s.SIMPLE_FLOAT){if(e<32)throw new Error(`Invalid simple encoding in extra byte: ${e}`);f=!0}else if(this.#i.requirePreferred&&e<24)throw new Error(`Unexpectedly long integer encoding (1) for ${e}`);break;case l.TWO:if(a=2,i===s.SIMPLE_FLOAT)e=E(this.#t,this.#e);else if(e=this.#r.getUint16(this.#e,!1),this.#i.requirePreferred&&e<=255)throw new Error(`Unexpectedly long integer encoding (2) for ${e}`);break;case l.FOUR:if(a=4,i===s.SIMPLE_FLOAT)e=this.#r.getFloat32(this.#e,!1);else if(e=this.#r.getUint32(this.#e,!1),this.#i.requirePreferred&&e<=65535)throw new Error(`Unexpectedly long integer encoding (4) for ${e}`);break;case l.EIGHT:{if(a=8,i===s.SIMPLE_FLOAT)e=this.#r.getFloat64(this.#e,!1);else if(e=this.#r.getBigUint64(this.#e,!1),e<=Number.MAX_SAFE_INTEGER&&(e=Number(e)),this.#i.requirePreferred&&e<=4294967295)throw new Error(`Unexpectedly long integer encoding (8) for ${e}`);break}case 28:case 29:case 30:throw new Error(`Additional info not implemented: ${n}`);case l.INDEFINITE:switch(i){case s.POS_INT:case s.NEG_INT:case s.TAG:throw new Error(`Invalid indefinite encoding for MT ${i}`);case s.SIMPLE_FLOAT:yield[i,n,d.BREAK,r,0];return}e=1/0;break;default:f=!0}switch(this.#e+=a,i){case s.POS_INT:yield[i,n,e,r,a];break;case s.NEG_INT:yield[i,n,typeof e==\"bigint\"?-1n-e:-1-Number(e),r,a];break;case s.BYTE_STRING:e===1/0?yield*this.#s(i,t,r):yield[i,n,this.#a(e),r,e];break;case s.UTF8_STRING:e===1/0?yield*this.#s(i,t,r):yield[i,n,p.decode(this.#a(e)),r,e];break;case s.ARRAY:if(e===1/0)yield*this.#s(i,t,r,!1);else{const o=Number(e);yield[i,n,o,r,a];for(let h=0;h<o;h++)yield*this.#n(t+1)}break;case s.MAP:if(e===1/0)yield*this.#s(i,t,r,!1);else{const o=Number(e);yield[i,n,o,r,a];for(let h=0;h<o;h++)yield*this.#n(t),yield*this.#n(t)}break;case s.TAG:yield[i,n,e,r,a],yield*this.#n(t);break;case s.SIMPLE_FLOAT:{const o=e;f&&(e=g.create(Number(e))),yield[i,n,e,r,o];break}}}#a(t){const r=u(this.#t,this.#e,this.#e+=t);if(r.length!==t)throw new Error(`Unexpected end of stream reading ${t} bytes, got ${r.length}`);return r}*#s(t,r,c,i=!0){for(yield[t,l.INDEFINITE,1/0,c,1/0];;){const n=this.#n(r),e=n.next(),[f,a,o]=e.value;if(o===d.BREAK){yield e.value,n.next();return}if(i){if(f!==t)throw new Error(`Unmatched major type.  Expected ${t}, got ${f}.`);if(a===l.INDEFINITE)throw new Error(\"New stream started in typed stream\")}yield e.value,yield*n}}}export{y as DecodeStream};\n", "import{DCBOR_INT as h,MT as a,NUMBYTES as u}from\"./constants.js\";import{DiagnosticSizes as j}from\"./options.js\";import{sortCoreDeterministic as y}from\"./sorts.js\";import{box as f,getEncoded as b,saveEncoded as N}from\"./box.js\";import{defaultEncodeOptions as E,encode as T}from\"./encoder.js\";import{stringToHex as p,u8concat as S,u8toHex as g}from\"./utils.js\";import{DecodeStream as I}from\"./decodeStream.js\";import{Simple as O}from\"./simple.js\";import{Tag as m}from\"./tag.js\";import{checkSubnormal as D}from\"./float.js\";const v=new Map([[u.ZERO,1],[u.ONE,2],[u.TWO,3],[u.FOUR,5],[u.EIGHT,9]]),A=new Uint8Array(0);function k(d,r){return!r.boxed&&!r.preferMap&&d.every(([i])=>typeof i==\"string\")?Object.fromEntries(d):new Map(d)}class w{static defaultDecodeOptions={...I.defaultOptions,ParentType:w,boxed:!1,cde:!1,dcbor:!1,diagnosticSizes:j.PREFERRED,convertUnsafeIntsToFloat:!1,createObject:k,pretty:!1,preferMap:!1,rejectLargeNegatives:!1,rejectBigInts:!1,rejectDuplicateKeys:!1,rejectFloats:!1,rejectInts:!1,rejectLongLoundNaN:!1,rejectLongFloats:!1,rejectNegativeZero:!1,rejectSimple:!1,rejectStreaming:!1,rejectStringsNotNormalizedAs:null,rejectSubnormals:!1,rejectUndefined:!1,rejectUnsafeFloatInts:!1,saveOriginal:!1,sortKeys:null,tags:null};static cdeDecodeOptions={cde:!0,rejectStreaming:!0,requirePreferred:!0,sortKeys:y};static dcborDecodeOptions={...this.cdeDecodeOptions,dcbor:!0,convertUnsafeIntsToFloat:!0,rejectDuplicateKeys:!0,rejectLargeNegatives:!0,rejectLongLoundNaN:!0,rejectLongFloats:!0,rejectNegativeZero:!0,rejectSimple:!0,rejectUndefined:!0,rejectUnsafeFloatInts:!0,rejectStringsNotNormalizedAs:\"NFC\"};parent;mt;ai;left;offset;count=0;children=[];depth=0;#e;#t=null;constructor(r,i,e,t){if([this.mt,this.ai,,this.offset]=r,this.left=i,this.parent=e,this.#e=t,e&&(this.depth=e.depth+1),this.mt===a.MAP&&(this.#e.sortKeys||this.#e.rejectDuplicateKeys)&&(this.#t=[]),this.#e.rejectStreaming&&this.ai===u.INDEFINITE)throw new Error(\"Streaming not supported\")}get isStreaming(){return this.left===1/0}get done(){return this.left===0}static create(r,i,e,t){const[s,l,n,c]=r;switch(s){case a.POS_INT:case a.NEG_INT:{if(e.rejectInts)throw new Error(`Unexpected integer: ${n}`);if(e.rejectLargeNegatives&&n<-0x8000000000000000n)throw new Error(`Invalid 65bit negative number: ${n}`);let o=n;return e.convertUnsafeIntsToFloat&&o>=h.MIN&&o<=h.MAX&&(o=Number(n)),e.boxed?f(o,t.toHere(c)):o}case a.SIMPLE_FLOAT:if(l>u.ONE){if(e.rejectFloats)throw new Error(`Decoding unwanted floating point number: ${n}`);if(e.rejectNegativeZero&&Object.is(n,-0))throw new Error(\"Decoding negative zero\");if(e.rejectLongLoundNaN&&isNaN(n)){const o=t.toHere(c);if(o.length!==3||o[1]!==126||o[2]!==0)throw new Error(`Invalid NaN encoding: \"${g(o)}\"`)}if(e.rejectSubnormals&&D(t.toHere(c+1)),e.rejectLongFloats){const o=T(n,{chunkSize:9,reduceUnsafeNumbers:e.rejectUnsafeFloatInts});if(o[0]>>5!==s)throw new Error(`Should have been encoded as int, not float: ${n}`);if(o.length<v.get(l))throw new Error(`Number should have been encoded shorter: ${n}`)}if(typeof n==\"number\"&&e.boxed)return f(n,t.toHere(c))}else{if(e.rejectSimple&&n instanceof O)throw new Error(`Invalid simple value: ${n}`);if(e.rejectUndefined&&n===void 0)throw new Error(\"Unexpected undefined\")}return n;case a.BYTE_STRING:case a.UTF8_STRING:if(n===1/0)return new e.ParentType(r,1/0,i,e);if(e.rejectStringsNotNormalizedAs&&typeof n==\"string\"){const o=n.normalize(e.rejectStringsNotNormalizedAs);if(n!==o)throw new Error(`String not normalized as \"${e.rejectStringsNotNormalizedAs}\", got [${p(n)}] instead of [${p(o)}]`)}return e.boxed?f(n,t.toHere(c)):n;case a.ARRAY:return new e.ParentType(r,n,i,e);case a.MAP:return new e.ParentType(r,n*2,i,e);case a.TAG:{const o=new e.ParentType(r,1,i,e);return o.children=new m(n),o}}throw new TypeError(`Invalid major type: ${s}`)}static decodeToEncodeOpts(r){return{...E,avoidInts:r.rejectInts,float64:!r.rejectLongFloats,flushToZero:r.rejectSubnormals,largeNegativeAsBigInt:r.rejectLargeNegatives,sortKeys:r.sortKeys}}push(r,i,e){if(this.children.push(r),this.#t){const t=b(r)||i.toHere(e);this.#t.push(t)}return--this.left}replaceLast(r,i,e){let t,s=-1/0;if(this.children instanceof m?(s=0,t=this.children.contents,this.children.contents=r):(s=this.children.length-1,t=this.children[s],this.children[s]=r),this.#t){const l=b(r)||e.toHere(i.offset);this.#t[s]=l}return t}convert(r){let i;switch(this.mt){case a.ARRAY:i=this.children;break;case a.MAP:{const e=this.#r();if(this.#e.sortKeys){let t;for(const s of e){if(t&&this.#e.sortKeys(t,s)>=0)throw new Error(`Duplicate or out of order key: \"0x${s[2]}\"`);t=s}}else if(this.#e.rejectDuplicateKeys){const t=new Set;for(const[s,l,n]of e){const c=g(n);if(t.has(c))throw new Error(`Duplicate key: \"0x${c}\"`);t.add(c)}}i=this.#e.createObject(e,this.#e);break}case a.BYTE_STRING:return S(this.children);case a.UTF8_STRING:{const e=this.children.join(\"\");i=this.#e.boxed?f(e,r.toHere(this.offset)):e;break}case a.TAG:i=this.children.decode(this.#e);break;default:throw new TypeError(`Invalid mt on convert: ${this.mt}`)}return this.#e.saveOriginal&&i&&typeof i==\"object\"&&N(i,r.toHere(this.offset)),i}#r(){const r=this.children,i=r.length;if(i%2)throw new Error(\"Missing map value\");const e=new Array(i/2);if(this.#t)for(let t=0;t<i;t+=2)e[t>>1]=[r[t],r[t+1],this.#t[t]];else for(let t=0;t<i;t+=2)e[t>>1]=[r[t],r[t+1],A];return e}}export{w as CBORcontainer};\n", "import{DiagnosticSizes as b}from\"./options.js\";import{MT as s,NUMBYTES as f,SYMS as d}from\"./constants.js\";import{CBORcontainer as S}from\"./container.js\";import{DecodeStream as E}from\"./decodeStream.js\";import{Simple as N}from\"./simple.js\";import{halfToUint as I}from\"./float.js\";import{u8toHex as _}from\"./utils.js\";const O=\"  \",y=new TextEncoder;class g extends S{close=\"\";quote='\"';get isEmptyStream(){return(this.mt===s.UTF8_STRING||this.mt===s.BYTE_STRING)&&this.count===0}}function a(m,l,n,p){let t=\"\";if(l===f.INDEFINITE)t+=\"_\";else{if(p.diagnosticSizes===b.NEVER)return\"\";{let r=p.diagnosticSizes===b.ALWAYS;if(!r){let e=f.ZERO;if(Object.is(n,-0))e=f.TWO;else if(m===s.POS_INT||m===s.NEG_INT){const T=n<0,u=typeof n==\"bigint\"?1n:1,o=T?-n-u:n;o<=23?e=Number(o):o<=255?e=f.ONE:o<=65535?e=f.TWO:o<=4294967295?e=f.FOUR:e=f.EIGHT}else isFinite(n)?Math.fround(n)===n?I(n)==null?e=f.FOUR:e=f.TWO:e=f.EIGHT:e=f.TWO;r=e!==l}r&&(t+=\"_\",l<f.ONE?t+=\"i\":t+=String(l-24))}}return t}function M(m,l){const n={...S.defaultDecodeOptions,...l,ParentType:g},p=new E(m,n);let t,r,e=\"\";for(const T of p){const[u,o,i]=T;switch(t&&(t.count>0&&i!==d.BREAK&&(t.mt===s.MAP&&t.count%2?e+=\": \":(e+=\",\",n.pretty||(e+=\" \"))),n.pretty&&(t.mt!==s.MAP||t.count%2===0)&&(e+=`\n${O.repeat(t.depth+1)}`)),r=S.create(T,t,n,p),u){case s.POS_INT:case s.NEG_INT:e+=String(i),e+=a(u,o,i,n);break;case s.SIMPLE_FLOAT:if(i!==d.BREAK)if(typeof i==\"number\"){const c=Object.is(i,-0)?\"-0.0\":String(i);e+=c,isFinite(i)&&!/[.e]/.test(c)&&(e+=\".0\"),e+=a(u,o,i,n)}else i instanceof N?(e+=\"simple(\",e+=String(i.value),e+=a(s.POS_INT,o,i.value,n),e+=\")\"):e+=String(i);break;case s.BYTE_STRING:i===1/0?(e+=\"(_ \",r.close=\")\",r.quote=\"'\"):(e+=\"h'\",e+=_(i),e+=\"'\",e+=a(s.POS_INT,o,i.length,n));break;case s.UTF8_STRING:i===1/0?(e+=\"(_ \",r.close=\")\"):(e+=JSON.stringify(i),e+=a(s.POS_INT,o,y.encode(i).length,n));break;case s.ARRAY:{e+=\"[\";const c=a(s.POS_INT,o,i,n);e+=c,c&&(e+=\" \"),n.pretty&&i?r.close=`\n${O.repeat(r.depth)}]`:r.close=\"]\";break}case s.MAP:{e+=\"{\";const c=a(s.POS_INT,o,i,n);e+=c,c&&(e+=\" \"),n.pretty&&i?r.close=`\n${O.repeat(r.depth)}}`:r.close=\"}\";break}case s.TAG:e+=String(i),e+=a(s.POS_INT,o,i,n),e+=\"(\",r.close=\")\";break}if(r===d.BREAK)if(t?.isStreaming)t.left=0;else throw new Error(\"Unexpected BREAK\");else t&&(t.count++,t.left--);for(r instanceof g&&(t=r);t?.done;){if(t.isEmptyStream)e=e.slice(0,-3),e+=`${t.quote}${t.quote}_`;else{if(t.mt===s.MAP&&t.count%2!==0)throw new Error(`Odd streaming map size: ${t.count}`);e+=t.close}t=t.parent}}return e}export{M as diagnose};\n", "import{MT as u,NUMBYTES as b,SYMS as E}from\"./constants.js\";import{getEncoded as B,saveEncoded as R}from\"./box.js\";import{getRanges as S,subarrayRanges as I,u8toHex as C}from\"./utils.js\";import{CBORcontainer as T}from\"./container.js\";import{DecodeStream as M}from\"./decodeStream.js\";import{Simple as N}from\"./simple.js\";import{Tag as P}from\"./tag.js\";import{diagnose as U}from\"./diagnostic.js\";const H=new TextDecoder;class A extends T{depth=0;leaf=!1;value;length;[E.ENCODED];constructor(a,f,e,n){super(a,f,e,n),this.parent?this.depth=this.parent.depth+1:this.depth=n.initialDepth,[,,this.value,,this.length]=a}numBytes(){switch(this.ai){case b.ONE:return 1;case b.TWO:return 2;case b.FOUR:return 4;case b.EIGHT:return 8}return 0}}function k(t){return t instanceof A}function O(t,a){return t===1/0?\"Indefinite\":a?`${t} ${a}${t!==1&&t!==1n?\"s\":\"\"}`:String(t)}function y(t){return\"\".padStart(t,\" \")}function x(t,a,f){let e=\"\";e+=y(t.depth*2);const n=B(t);e+=C(n.subarray(0,1));const r=t.numBytes();r&&(e+=\" \",e+=C(n.subarray(1,r+1))),e=e.padEnd(a.minCol+1,\" \"),e+=\"-- \",f!==void 0&&(e+=y(t.depth*2),f!==\"\"&&(e+=`[${f}] `));let p=!1;const[s]=t.children;switch(t.mt){case u.POS_INT:e+=`Unsigned: ${s}`,typeof s==\"bigint\"&&(e+=\"n\");break;case u.NEG_INT:e+=`Negative: ${s}`,typeof s==\"bigint\"&&(e+=\"n\");break;case u.BYTE_STRING:e+=`Bytes (Length: ${O(t.length)})`;break;case u.UTF8_STRING:e+=`UTF8 (Length: ${O(t.length)})`,t.length!==1/0&&(e+=`: ${JSON.stringify(s)}`);break;case u.ARRAY:e+=`Array (Length: ${O(t.value,\"item\")})`;break;case u.MAP:e+=`Map (Length: ${O(t.value,\"pair\")})`;break;case u.TAG:{e+=`Tag #${t.value}`;const o=t.children,[m]=o.contents.children,i=new P(o.tag,m);R(i,n);const l=i.comment(a,t.depth);l&&(e+=\": \",e+=l),p||=i.noChildren;break}case u.SIMPLE_FLOAT:s===E.BREAK?e+=\"BREAK\":t.ai>b.ONE?Object.is(s,-0)?e+=\"Float: -0\":e+=`Float: ${s}`:(e+=\"Simple: \",s instanceof N?e+=s.value:e+=s);break}if(!p)if(t.leaf){if(e+=`\n`,n.length>r+1){const o=y((t.depth+1)*2),m=S(n);if(m?.length){m.sort((l,c)=>{const g=l[0]-c[0];return g||c[1]-l[1]});let i=0;for(const[l,c,g]of m)if(!(l<i)){if(i=l+c,g===\"<<\"){e+=y(a.minCol+1),e+=\"--\",e+=o,e+=\"<< \";const d=I(n,l,l+c),h=S(d);if(h){const $=h.findIndex(([w,D,v])=>w===0&&D===c&&v===\"<<\");$>=0&&h.splice($,1)}e+=U(d),e+=` >>\n`,e+=L(d,{initialDepth:t.depth+1,minCol:a.minCol,noPrefixHex:!0});continue}else g===\"'\"&&(e+=y(a.minCol+1),e+=\"--\",e+=o,e+=\"'\",e+=H.decode(n.subarray(l,l+c)),e+=`'\n`);if(l>r)for(let d=l;d<l+c;d+=8){const h=Math.min(d+8,l+c);e+=o,e+=C(n.subarray(d,h)),e+=`\n`}}}else for(let i=r+1;i<n.length;i+=8)e+=o,e+=C(n.subarray(i,i+8)),e+=`\n`}}else{e+=`\n`;let o=0;for(const m of t.children){if(k(m)){let i=String(o);t.mt===u.MAP?i=o%2?`val ${(o-1)/2}`:`key ${o/2}`:t.mt===u.TAG&&(i=\"\"),e+=x(m,a,i)}o++}}return e}const q={...T.defaultDecodeOptions,initialDepth:0,noPrefixHex:!1,minCol:0};function L(t,a){const f={...q,...a,ParentType:A,saveOriginal:!0},e=new M(t,f);let n,r;for(const s of e){if(r=T.create(s,n,f,e),s[2]===E.BREAK)if(n?.isStreaming)n.left=1;else throw new Error(\"Unexpected BREAK\");if(!k(r)){const i=new A(s,0,n,f);i.leaf=!0,i.children.push(r),R(i,e.toHere(s[3])),r=i}let o=(r.depth+1)*2;const m=r.numBytes();for(m&&(o+=1,o+=m*2),f.minCol=Math.max(f.minCol,o),n&&n.push(r,e,s[3]),n=r;n?.done;)r=n,r.leaf||R(r,e.toHere(r.offset)),{parent:n}=n}a&&(a.minCol=f.minCol);let p=f.noPrefixHex?\"\":`0x${C(e.toHere(0))}\n`;return p+=x(r,f),p}export{L as comment};\n", "import{MT as R,TAG as a}from\"./constants.js\";import{box as L,getEncoded as q}from\"./box.js\";import{base64ToBytes as C,base64UrlToBytes as v,isBigEndian as V,u8toHex as A}from\"./utils.js\";import{encode as b,registerEncoder as s,writeInt as W,writeLength as k,writeTag as F,writeUnknown as P}from\"./encoder.js\";import{CBORcontainer as M}from\"./container.js\";import{Tag as i}from\"./tag.js\";import{Wtf8Decoder as B}from\"@cto.af/wtf8\";import{comment as K}from\"./comment.js\";const S=!V();function O(e){if(typeof e==\"object\"&&e){if(e.constructor!==Number)throw new Error(`Expected number: ${e}`)}else if(typeof e!=\"number\")throw new Error(`Expected number: ${e}`)}function E(e){if(typeof e==\"object\"&&e){if(e.constructor!==String)throw new Error(`Expected string: ${e}`)}else if(typeof e!=\"string\")throw new Error(`Expected string: ${e}`)}function f(e){if(!(e instanceof Uint8Array))throw new Error(`Expected Uint8Array: ${e}`)}function U(e){if(!Array.isArray(e))throw new Error(`Expected Array: ${e}`)}s(Map,(e,r,n)=>{const t=[...e.entries()].map(o=>[o[0],o[1],b(o[0],n)]);if(n.rejectDuplicateKeys){const o=new Set;for(const[d,u,y]of t){const g=A(y);if(o.has(g))throw new Error(`Duplicate map key: 0x${g}`);o.add(g)}}n.sortKeys&&t.sort(n.sortKeys),k(e,e.size,R.MAP,r,n);for(const[o,d,u]of t)r.write(u),P(d,r,n)});function h(e){return E(e.contents),new Date(e.contents)}h.comment=e=>(E(e.contents),`(String Date) ${new Date(e.contents).toISOString()}`),i.registerDecoder(a.DATE_STRING,h);function N(e){return O(e.contents),new Date(e.contents*1e3)}N.comment=e=>(O(e.contents),`(Epoch Date) ${new Date(e.contents*1e3).toISOString()}`),i.registerDecoder(a.DATE_EPOCH,N),s(Date,e=>[a.DATE_EPOCH,e.valueOf()/1e3]);function T(e,r,n){if(f(r.contents),n.rejectBigInts)throw new Error(`Decoding unwanted big integer: ${r}(h'${A(r.contents)}')`);if(n.requirePreferred&&r.contents[0]===0)throw new Error(`Decoding overly-large bigint: ${r.tag}(h'${A(r.contents)})`);let t=r.contents.reduce((o,d)=>o<<8n|BigInt(d),0n);if(e&&(t=-1n-t),n.requirePreferred&&t>=Number.MIN_SAFE_INTEGER&&t<=Number.MAX_SAFE_INTEGER)throw new Error(`Decoding bigint that could have been int: ${t}n`);return n.boxed?L(t,r.contents):t}const _=T.bind(null,!1),$=T.bind(null,!0);_.comment=(e,r)=>`(Positive BigInt) ${T(!1,e,r)}n`,$.comment=(e,r)=>`(Negative BigInt) ${T(!0,e,r)}n`,i.registerDecoder(a.POS_BIGINT,_),i.registerDecoder(a.NEG_BIGINT,$);function D(e,r){return f(e.contents),e}D.comment=(e,r,n)=>{f(e.contents);const t={...r,initialDepth:n+2,noPrefixHex:!0},o=q(e);let u=2**((o[0]&31)-24)+1;const y=o[u]&31;let g=A(o.subarray(u,++u));y>=24&&(g+=\" \",g+=A(o.subarray(u,u+2**(y-24)))),t.minCol=Math.max(t.minCol,(n+1)*2+g.length);const p=K(e.contents,t);let I=`Embedded CBOR\n`;return I+=`${\"\".padStart((n+1)*2,\" \")}${g}`.padEnd(t.minCol+1,\" \"),I+=`-- Bytes (Length: ${e.contents.length})\n`,I+=p,I},D.noChildren=!0,i.registerDecoder(a.CBOR,D),i.registerDecoder(a.URI,e=>(E(e.contents),new URL(e.contents)),\"URI\"),s(URL,e=>[a.URI,e.toString()]),i.registerDecoder(a.BASE64URL,e=>(E(e.contents),v(e.contents)),\"Base64url-encoded\"),i.registerDecoder(a.BASE64,e=>(E(e.contents),C(e.contents)),\"Base64-encoded\"),i.registerDecoder(35,e=>(E(e.contents),new RegExp(e.contents)),\"RegExp\"),i.registerDecoder(21065,e=>{E(e.contents);const r=`^(?:${e.contents})$`;return new RegExp(r,\"u\")},\"I-RegExp\"),i.registerDecoder(a.REGEXP,e=>{if(U(e.contents),e.contents.length<1||e.contents.length>2)throw new Error(`Invalid RegExp Array: ${e.contents}`);return new RegExp(e.contents[0],e.contents[1])},\"RegExp\"),s(RegExp,e=>[a.REGEXP,[e.source,e.flags]]),i.registerDecoder(64,e=>(f(e.contents),e.contents),\"uint8 Typed Array\");function c(e,r,n){f(e.contents);let t=e.contents.length;if(t%r.BYTES_PER_ELEMENT!==0)throw new Error(`Number of bytes must be divisible by ${r.BYTES_PER_ELEMENT}, got: ${t}`);t/=r.BYTES_PER_ELEMENT;const o=new r(t),d=new DataView(e.contents.buffer,e.contents.byteOffset,e.contents.byteLength),u=d[`get${r.name.replace(/Array/,\"\")}`].bind(d);for(let y=0;y<t;y++)o[y]=u(y*r.BYTES_PER_ELEMENT,n);return o}function l(e,r,n,t,o){const d=o.forceEndian??S;if(F(d?r:n,e,o),W(t.byteLength,e,R.BYTE_STRING),S===d)e.write(new Uint8Array(t.buffer,t.byteOffset,t.byteLength));else{const y=`write${t.constructor.name.replace(/Array/,\"\")}`,g=e[y].bind(e);for(const p of t)g(p,d)}}i.registerDecoder(65,e=>c(e,Uint16Array,!1),\"uint16, big endian, Typed Array\"),i.registerDecoder(66,e=>c(e,Uint32Array,!1),\"uint32, big endian, Typed Array\"),i.registerDecoder(67,e=>c(e,BigUint64Array,!1),\"uint64, big endian, Typed Array\"),i.registerDecoder(68,e=>(f(e.contents),new Uint8ClampedArray(e.contents)),\"uint8 Typed Array, clamped arithmetic\"),s(Uint8ClampedArray,e=>[68,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)]),i.registerDecoder(69,e=>c(e,Uint16Array,!0),\"uint16, little endian, Typed Array\"),s(Uint16Array,(e,r,n)=>l(r,69,65,e,n)),i.registerDecoder(70,e=>c(e,Uint32Array,!0),\"uint32, little endian, Typed Array\"),s(Uint32Array,(e,r,n)=>l(r,70,66,e,n)),i.registerDecoder(71,e=>c(e,BigUint64Array,!0),\"uint64, little endian, Typed Array\"),s(BigUint64Array,(e,r,n)=>l(r,71,67,e,n)),i.registerDecoder(72,e=>(f(e.contents),new Int8Array(e.contents)),\"sint8 Typed Array\"),s(Int8Array,e=>[72,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)]),i.registerDecoder(73,e=>c(e,Int16Array,!1),\"sint16, big endian, Typed Array\"),i.registerDecoder(74,e=>c(e,Int32Array,!1),\"sint32, big endian, Typed Array\"),i.registerDecoder(75,e=>c(e,BigInt64Array,!1),\"sint64, big endian, Typed Array\"),i.registerDecoder(77,e=>c(e,Int16Array,!0),\"sint16, little endian, Typed Array\"),s(Int16Array,(e,r,n)=>l(r,77,73,e,n)),i.registerDecoder(78,e=>c(e,Int32Array,!0),\"sint32, little endian, Typed Array\"),s(Int32Array,(e,r,n)=>l(r,78,74,e,n)),i.registerDecoder(79,e=>c(e,BigInt64Array,!0),\"sint64, little endian, Typed Array\"),s(BigInt64Array,(e,r,n)=>l(r,79,75,e,n)),i.registerDecoder(81,e=>c(e,Float32Array,!1),\"IEEE 754 binary32, big endian, Typed Array\"),i.registerDecoder(82,e=>c(e,Float64Array,!1),\"IEEE 754 binary64, big endian, Typed Array\"),i.registerDecoder(85,e=>c(e,Float32Array,!0),\"IEEE 754 binary32, little endian, Typed Array\"),s(Float32Array,(e,r,n)=>l(r,85,81,e,n)),i.registerDecoder(86,e=>c(e,Float64Array,!0),\"IEEE 754 binary64, big endian, Typed Array\"),s(Float64Array,(e,r,n)=>l(r,86,82,e,n)),i.registerDecoder(a.SET,(e,r)=>{if(U(e.contents),r.sortKeys){const n=M.decodeToEncodeOpts(r);let t=null;for(const o of e.contents){const d=[o,void 0,b(o,n)];if(t&&r.sortKeys(t,d)>=0)throw new Error(`Set items out of order in tag #${a.SET}`);t=d}}return new Set(e.contents)},\"Set\"),s(Set,(e,r,n)=>{let t=[...e];if(n.sortKeys){const o=t.map(d=>[d,void 0,b(d,n)]);o.sort(n.sortKeys),t=o.map(([d])=>d)}return[a.SET,t]}),i.registerDecoder(a.JSON,e=>(E(e.contents),JSON.parse(e.contents)),\"JSON-encoded\");function x(e){return f(e.contents),new B().decode(e.contents)}x.comment=e=>{f(e.contents);const r=new B;return`(WTF8 string): ${JSON.stringify(r.decode(e.contents))}`},i.registerDecoder(a.WTF8,x),i.registerDecoder(a.SELF_DESCRIBED,e=>e.contents,\"Self-Described\"),i.registerDecoder(a.INVALID_16,()=>{throw new Error(`Tag always invalid: ${a.INVALID_16}`)},\"Invalid\"),i.registerDecoder(a.INVALID_32,()=>{throw new Error(`Tag always invalid: ${a.INVALID_32}`)},\"Invalid\"),i.registerDecoder(a.INVALID_64,()=>{throw new Error(`Tag always invalid: ${a.INVALID_64}`)},\"Invalid\");function w(e){throw new Error(`Encoding ${e.constructor.name} intentionally unimplmented.  It is not concrete enough to interoperate.  Convert to Uint8Array first.`)}s(ArrayBuffer,w),s(DataView,w),typeof SharedArrayBuffer<\"u\"&&s(SharedArrayBuffer,w);function m(e){return[NaN,e.valueOf()]}s(Boolean,m),s(Number,m),s(String,m),s(BigInt,m);\n", "const o=\"2.0.1\";export{o as version};\n", "import{DecodeStream as a}from\"./decodeStream.js\";import{CBORcontainer as s}from\"./container.js\";import{SYMS as u}from\"./constants.js\";function c(i){const e={...s.defaultDecodeOptions};if(i.dcbor?Object.assign(e,s.dcborDecodeOptions):i.cde&&Object.assign(e,s.cdeDecodeOptions),Object.assign(e,i),Object.hasOwn(e,\"rejectLongNumbers\"))throw new TypeError(\"rejectLongNumbers has changed to requirePreferred\");return e.boxed&&(e.saveOriginal=!0),e}class d{parent=void 0;ret=void 0;step(e,n,t){if(this.ret=s.create(e,this.parent,n,t),e[2]===u.BREAK)if(this.parent?.isStreaming)this.parent.left=0;else throw new Error(\"Unexpected BREAK\");else this.parent&&this.parent.push(this.ret,t,e[3]);for(this.ret instanceof s&&(this.parent=this.ret);this.parent?.done;){this.ret=this.parent.convert(t);const r=this.parent.parent;r?.replaceLast(this.ret,this.parent,t),this.parent=r}}}function l(i,e={}){const n=c(e),t=new a(i,n),r=new d;for(const o of t)r.step(o,n,t);return r.ret}class O{#t;#e;constructor(e,n={}){const t=new a(e,c(n));this.#t=t.seq()}peek(){return this.#e||(this.#e=this.#n()),this.#e}read(){const e=this.#e??this.#n();return this.#e=void 0,e}*[Symbol.iterator](){for(;;){const e=this.read();if(!e)return;yield e}}#n(){const{value:e,done:n}=this.#t.next();if(!n)return e}}function*b(i,e={}){const n=c(e),t=new a(i,n),r=new d;for(const o of t.seq())r.step(o,n,t),r.parent||(yield r.ret)}export{O as SequenceEvents,l as decode,b as decodeSequence};\n", "/**\n * COSE Sign1 - High-level API\n * \n * This module provides a user-friendly API for COSE_Sign1 operations,\n * built on top of our minimal COSE Sign1 implementation.\n */\n\nimport * as sign1 from './cose/sign1.js';\n\n// Re-export core types and constants\nexport { HeaderParam, Alg, COSE_Sign1_Tag } from './cose/sign1.js';\n\n/**\n * COSE Sign1 algorithms supported (string aliases)\n */\nexport const Algorithm = {\n  ES256: 'ES256',\n  ES384: 'ES384',\n  ES512: 'ES512',\n};\n\n/**\n * Map string algorithm names to COSE algorithm identifiers\n */\nconst AlgNameToId = {\n  'ES256': sign1.Alg.ES256,\n  'ES384': sign1.Alg.ES384,\n  'ES512': sign1.Alg.ES512,\n};\n\n/**\n * Creates a COSE Sign1 signed message\n * \n * @param {Buffer|Uint8Array|string} payload - The payload to sign\n * @param {Object} signerKey - The signer's private key\n * @param {Buffer|Uint8Array} signerKey.d - The private key 'd' component\n * @param {Buffer|Uint8Array} signerKey.x - The public key 'x' coordinate\n * @param {Buffer|Uint8Array} signerKey.y - The public key 'y' coordinate\n * @param {Object} [options] - Optional parameters\n * @param {string} [options.algorithm='ES256'] - The signing algorithm\n * @param {string|Buffer} [options.kid] - Key identifier\n * @param {Object} [options.protectedHeaders] - Additional protected headers (string keys)\n * @param {Object} [options.unprotectedHeaders] - Additional unprotected headers (string keys)\n * @param {Map|Object} [options.customProtectedHeaders] - Custom headers with integer keys\n * @param {Map|Object} [options.customUnprotectedHeaders] - Custom headers with integer keys\n * @returns {Promise<Buffer>} The COSE Sign1 message\n */\nexport async function sign(payload, signerKey, options = {}) {\n  const {\n    algorithm = Algorithm.ES256,\n    kid,\n    protectedHeaders = {},\n    unprotectedHeaders = {},\n    customProtectedHeaders,\n    customUnprotectedHeaders,\n  } = options;\n\n  if (!payload) {\n    throw new Error('Payload is required');\n  }\n\n  if (!signerKey || !signerKey.d || !signerKey.x || !signerKey.y) {\n    throw new Error('Signer key must include d, x, and y components');\n  }\n\n  // Convert algorithm string to COSE algorithm identifier\n  const algId = AlgNameToId[algorithm];\n  if (algId === undefined) {\n    throw new Error(`Unsupported algorithm: ${algorithm}`);\n  }\n\n  // Build protected header Map\n  const protectedMap = new Map();\n  protectedMap.set(sign1.HeaderParam.Algorithm, algId);\n\n  // Add standard protected headers\n  for (const [key, value] of Object.entries(protectedHeaders)) {\n    const label = HeaderLabels[key];\n    if (label !== undefined) {\n      protectedMap.set(label, value);\n    }\n  }\n\n  // Add custom protected headers\n  if (customProtectedHeaders) {\n    const entries = customProtectedHeaders instanceof Map\n      ? customProtectedHeaders.entries()\n      : Object.entries(customProtectedHeaders);\n    for (const [key, value] of entries) {\n      protectedMap.set(Number(key), convertBufferValues(value));\n    }\n  }\n\n  // Build unprotected header Map\n  const unprotectedMap = new Map();\n  \n  if (kid) {\n    // Ensure kid is Uint8Array for proper CBOR encoding\n    const kidBuffer = typeof kid === 'string' ? Buffer.from(kid) : kid;\n    const kidValue = toUint8Array(kidBuffer);\n    unprotectedMap.set(sign1.HeaderParam.KeyId, kidValue);\n  }\n\n  // Add standard unprotected headers\n  for (const [key, value] of Object.entries(unprotectedHeaders)) {\n    const label = HeaderLabels[key];\n    if (label !== undefined) {\n      unprotectedMap.set(label, value);\n    }\n  }\n\n  // Add custom unprotected headers\n  if (customUnprotectedHeaders) {\n    const entries = customUnprotectedHeaders instanceof Map\n      ? customUnprotectedHeaders.entries()\n      : Object.entries(customUnprotectedHeaders);\n    for (const [key, value] of entries) {\n      unprotectedMap.set(Number(key), convertBufferValues(value));\n    }\n  }\n\n  // Ensure payload is Uint8Array\n  let payloadBytes;\n  if (payload instanceof Uint8Array) {\n    payloadBytes = payload;\n  } else if (Buffer.isBuffer(payload)) {\n    payloadBytes = new Uint8Array(payload);\n  } else {\n    payloadBytes = new Uint8Array(Buffer.from(payload));\n  }\n\n  // Ensure key components are Uint8Array\n  const key = {\n    d: toUint8Array(signerKey.d),\n    x: toUint8Array(signerKey.x),\n    y: toUint8Array(signerKey.y),\n  };\n\n  const signed = await sign1.sign({\n    protectedHeader: protectedMap,\n    unprotectedHeader: unprotectedMap,\n    payload: payloadBytes,\n    key,\n  });\n\n  return Buffer.from(signed);\n}\n\n/**\n * Verifies a COSE Sign1 message and returns the payload\n * \n * @param {Buffer|Uint8Array} coseSign1 - The COSE Sign1 message to verify\n * @param {Object} verifierKey - The verifier's public key\n * @param {Buffer|Uint8Array} verifierKey.x - The public key 'x' coordinate\n * @param {Buffer|Uint8Array} verifierKey.y - The public key 'y' coordinate\n * @returns {Promise<Buffer>} The verified payload\n * @throws {Error} If verification fails\n */\nexport async function verify(coseSign1, verifierKey) {\n  if (!coseSign1) {\n    throw new Error('COSE Sign1 message is required');\n  }\n\n  if (!verifierKey || !verifierKey.x || !verifierKey.y) {\n    throw new Error('Verifier key must include x and y components');\n  }\n\n  const key = {\n    x: toUint8Array(verifierKey.x),\n    y: toUint8Array(verifierKey.y),\n  };\n\n  const messageBytes = toUint8Array(coseSign1);\n\n  const payload = await sign1.verify(messageBytes, key);\n  return Buffer.from(payload);\n}\n\n/**\n * Extracts headers from a COSE Sign1 message without verification\n * \n * @param {Buffer|Uint8Array} coseSign1 - The COSE Sign1 message\n * @returns {Object} Object containing protectedHeaders and unprotectedHeaders as Maps\n */\nexport function getHeaders(coseSign1) {\n  if (!coseSign1) {\n    throw new Error('COSE Sign1 message is required');\n  }\n\n  const messageBytes = toUint8Array(coseSign1);\n\n  const decoded = sign1.decode(messageBytes);\n  \n  return {\n    protectedHeaders: decoded.protectedHeader,\n    unprotectedHeaders: decoded.unprotectedHeader,\n  };\n}\n\n/**\n * Generates a key pair for COSE Sign1 operations\n * \n * @param {string} [algorithm='ES256'] - The algorithm to generate keys for\n * @returns {Object} An object containing privateKey and publicKey with Buffer components\n */\nexport function generateKeyPair(algorithm = Algorithm.ES256) {\n  const algId = AlgNameToId[algorithm];\n  if (algId === undefined) {\n    throw new Error(`Unsupported algorithm: ${algorithm}`);\n  }\n\n  const { privateKey, publicKey } = sign1.generateKeyPair(algId);\n\n  return {\n    privateKey: {\n      d: Buffer.from(privateKey.d),\n      x: Buffer.from(privateKey.x),\n      y: Buffer.from(privateKey.y),\n    },\n    publicKey: {\n      x: Buffer.from(publicKey.x),\n      y: Buffer.from(publicKey.y),\n    },\n  };\n}\n\n/**\n * Standard COSE header labels for string key conversion\n */\nconst HeaderLabels = {\n  alg: sign1.HeaderParam.Algorithm,\n  crit: sign1.HeaderParam.Critical,\n  content_type: sign1.HeaderParam.ContentType,\n  ctyp: sign1.HeaderParam.ContentType,\n  kid: sign1.HeaderParam.KeyId,\n  IV: sign1.HeaderParam.IV,\n  Partial_IV: sign1.HeaderParam.PartialIV,\n  counter_signature: sign1.HeaderParam.CounterSignature,\n  x5chain: sign1.HeaderParam.X5Chain,\n};\n\n/**\n * Helper to convert Buffer or Uint8Array to pure Uint8Array\n * (Buffer extends Uint8Array but we need pure Uint8Array for crypto operations)\n * Always creates a copy to avoid issues with views over shared buffers.\n */\nfunction toUint8Array(value) {\n  if (Buffer.isBuffer(value)) {\n    // Create a copy to avoid issues with views over shared buffers\n    const copy = new Uint8Array(value.length);\n    copy.set(value);\n    return copy;\n  }\n  if (value instanceof Uint8Array) {\n    // Create a copy to avoid issues with views\n    const copy = new Uint8Array(value.length);\n    copy.set(value);\n    return copy;\n  }\n  return new Uint8Array(Buffer.from(value));\n}\n\n/**\n * Recursively converts Buffer values to Uint8Array in a value\n * (cbor2 encodes Buffer differently than Uint8Array)\n * Always creates copies to avoid issues with views over shared buffers.\n */\nfunction convertBufferValues(value) {\n  if (Buffer.isBuffer(value)) {\n    // Create a copy to avoid issues with views over shared buffers\n    const copy = new Uint8Array(value.length);\n    copy.set(value);\n    return copy;\n  }\n  if (value instanceof Uint8Array) {\n    // Create a copy to avoid issues with views\n    const copy = new Uint8Array(value.length);\n    copy.set(value);\n    return copy;\n  }\n  if (Array.isArray(value)) {\n    return value.map(convertBufferValues);\n  }\n  if (value instanceof Map) {\n    const result = new Map();\n    for (const [k, v] of value) {\n      result.set(k, convertBufferValues(v));\n    }\n    return result;\n  }\n  if (value !== null && typeof value === 'object') {\n    const result = {};\n    for (const [k, v] of Object.entries(value)) {\n      result[k] = convertBufferValues(v);\n    }\n    return result;\n  }\n  return value;\n}\n", "/**\n * Browser-compatible crypto shim using Web Crypto API\n * \n * This provides the crypto functions needed by sd-cwt in the browser.\n * Includes pure JavaScript SHA-256 for synchronous hashing.\n */\n\n// Use the global crypto object in the browser\nconst webcrypto = typeof globalThis.crypto !== 'undefined' ? globalThis.crypto : null;\n\nif (!webcrypto) {\n  throw new Error('Web Crypto API not available. Are you running in a secure context (HTTPS)?');\n}\n\n/**\n * Pure JavaScript SHA-256 implementation for synchronous hashing in browser\n * Based on the FIPS 180-4 specification\n */\nconst SHA256 = (() => {\n  const K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n  ]);\n\n  const H_INIT = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n  ]);\n\n  function rotr(x, n) {\n    return ((x >>> n) | (x << (32 - n))) >>> 0;\n  }\n\n  function ch(x, y, z) {\n    return ((x & y) ^ (~x & z)) >>> 0;\n  }\n\n  function maj(x, y, z) {\n    return ((x & y) ^ (x & z) ^ (y & z)) >>> 0;\n  }\n\n  function sigma0(x) {\n    return (rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22)) >>> 0;\n  }\n\n  function sigma1(x) {\n    return (rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25)) >>> 0;\n  }\n\n  function gamma0(x) {\n    return (rotr(x, 7) ^ rotr(x, 18) ^ (x >>> 3)) >>> 0;\n  }\n\n  function gamma1(x) {\n    return (rotr(x, 17) ^ rotr(x, 19) ^ (x >>> 10)) >>> 0;\n  }\n\n  function hash(message) {\n    // Pre-processing: adding padding bits\n    const msgLen = message.length;\n    const bitLen = msgLen * 8;\n    \n    // Calculate padded length: message + 1 byte (0x80) + padding + 8 bytes (length)\n    const padLen = ((msgLen + 9 + 63) & ~63);\n    const padded = new Uint8Array(padLen);\n    padded.set(message);\n    padded[msgLen] = 0x80;\n    \n    // Append length in bits as 64-bit big-endian\n    const view = new DataView(padded.buffer);\n    view.setUint32(padLen - 4, bitLen, false);\n    \n    // Initialize hash values\n    const H = new Uint32Array(H_INIT);\n    const W = new Uint32Array(64);\n    \n    // Process each 512-bit block\n    for (let i = 0; i < padLen; i += 64) {\n      // Prepare message schedule\n      for (let t = 0; t < 16; t++) {\n        W[t] = view.getUint32(i + t * 4, false);\n      }\n      for (let t = 16; t < 64; t++) {\n        W[t] = (gamma1(W[t - 2]) + W[t - 7] + gamma0(W[t - 15]) + W[t - 16]) >>> 0;\n      }\n      \n      // Initialize working variables\n      let a = H[0], b = H[1], c = H[2], d = H[3];\n      let e = H[4], f = H[5], g = H[6], h = H[7];\n      \n      // Main loop\n      for (let t = 0; t < 64; t++) {\n        const T1 = (h + sigma1(e) + ch(e, f, g) + K[t] + W[t]) >>> 0;\n        const T2 = (sigma0(a) + maj(a, b, c)) >>> 0;\n        h = g;\n        g = f;\n        f = e;\n        e = (d + T1) >>> 0;\n        d = c;\n        c = b;\n        b = a;\n        a = (T1 + T2) >>> 0;\n      }\n      \n      // Update hash values\n      H[0] = (H[0] + a) >>> 0;\n      H[1] = (H[1] + b) >>> 0;\n      H[2] = (H[2] + c) >>> 0;\n      H[3] = (H[3] + d) >>> 0;\n      H[4] = (H[4] + e) >>> 0;\n      H[5] = (H[5] + f) >>> 0;\n      H[6] = (H[6] + g) >>> 0;\n      H[7] = (H[7] + h) >>> 0;\n    }\n    \n    // Produce final hash\n    const result = new Uint8Array(32);\n    const resultView = new DataView(result.buffer);\n    for (let i = 0; i < 8; i++) {\n      resultView.setUint32(i * 4, H[i], false);\n    }\n    return result;\n  }\n\n  return { hash };\n})();\n\n/**\n * Create a hash using Web Crypto API\n * @param {string} algorithm - 'sha256', 'sha384', or 'sha512'\n * @param {Uint8Array} data - Data to hash\n * @returns {Promise<Uint8Array>}\n */\nasync function hashAsync(algorithm, data) {\n  const algoMap = {\n    'sha256': 'SHA-256',\n    'sha384': 'SHA-384',\n    'sha512': 'SHA-512',\n  };\n  const algoName = algoMap[algorithm.toLowerCase()];\n  if (!algoName) {\n    throw new Error(`Unsupported hash algorithm: ${algorithm}`);\n  }\n  const hashBuffer = await webcrypto.subtle.digest(algoName, data);\n  return new Uint8Array(hashBuffer);\n}\n\n/**\n * Synchronous hash implementation for browser using pure JavaScript\n * Compatible with Node.js crypto.createHash interface\n */\nfunction createHash(algorithm) {\n  const normalizedAlg = algorithm.toLowerCase().replace('-', '');\n  if (normalizedAlg !== 'sha256') {\n    throw new Error(`Synchronous hashing only supports sha256 in browser, got: ${algorithm}`);\n  }\n  \n  let data = new Uint8Array(0);\n  \n  return {\n    update(input) {\n      // Concatenate input to data\n      const inputBytes = input instanceof Uint8Array ? input : \n        (ArrayBuffer.isView(input) ? new Uint8Array(input.buffer, input.byteOffset, input.byteLength) :\n        (typeof input === 'string' ? new TextEncoder().encode(input) : new Uint8Array(input)));\n      const newData = new Uint8Array(data.length + inputBytes.length);\n      newData.set(data);\n      newData.set(inputBytes, data.length);\n      data = newData;\n      return this;\n    },\n    digest() {\n      return SHA256.hash(data);\n    },\n  };\n}\n\n/**\n * Generate random bytes\n * @param {number} size \n * @returns {Uint8Array}\n */\nfunction randomBytes(size) {\n  const bytes = new Uint8Array(size);\n  webcrypto.getRandomValues(bytes);\n  return bytes;\n}\n\n/**\n * Create ECDSA key pair\n */\nasync function generateKeyPairAsync(namedCurve) {\n  const keyPair = await webcrypto.subtle.generateKey(\n    {\n      name: 'ECDSA',\n      namedCurve,\n    },\n    true,\n    ['sign', 'verify']\n  );\n\n  // Export to JWK format\n  const privateJwk = await webcrypto.subtle.exportKey('jwk', keyPair.privateKey);\n  const publicJwk = await webcrypto.subtle.exportKey('jwk', keyPair.publicKey);\n\n  // Convert base64url to Uint8Array\n  const base64urlDecode = (str) => {\n    const base64 = str.replace(/-/g, '+').replace(/_/g, '/');\n    const pad = base64.length % 4;\n    const padded = pad ? base64 + '='.repeat(4 - pad) : base64;\n    const binary = atob(padded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n  };\n\n  return {\n    privateKey: {\n      d: base64urlDecode(privateJwk.d),\n      x: base64urlDecode(privateJwk.x),\n      y: base64urlDecode(privateJwk.y),\n    },\n    publicKey: {\n      x: base64urlDecode(publicJwk.x),\n      y: base64urlDecode(publicJwk.y),\n    },\n  };\n}\n\n/**\n * Sign data with ECDSA\n */\nasync function signAsync(algorithm, privateKey, data) {\n  const curveMap = {\n    'ES256': 'P-256',\n    'ES384': 'P-384',\n    'ES512': 'P-521',\n  };\n  const hashMap = {\n    'ES256': 'SHA-256',\n    'ES384': 'SHA-384',\n    'ES512': 'SHA-512',\n  };\n  \n  const namedCurve = curveMap[algorithm];\n  const hashName = hashMap[algorithm];\n  \n  if (!namedCurve) {\n    throw new Error(`Unsupported algorithm: ${algorithm}`);\n  }\n\n  // Convert key to JWK format\n  const base64urlEncode = (bytes) => {\n    let binary = '';\n    for (let i = 0; i < bytes.length; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n  };\n\n  const jwk = {\n    kty: 'EC',\n    crv: namedCurve,\n    x: base64urlEncode(privateKey.x),\n    y: base64urlEncode(privateKey.y),\n    d: base64urlEncode(privateKey.d),\n  };\n\n  const key = await webcrypto.subtle.importKey(\n    'jwk',\n    jwk,\n    { name: 'ECDSA', namedCurve },\n    false,\n    ['sign']\n  );\n\n  const signature = await webcrypto.subtle.sign(\n    { name: 'ECDSA', hash: hashName },\n    key,\n    data\n  );\n\n  return new Uint8Array(signature);\n}\n\n/**\n * Verify ECDSA signature\n */\nasync function verifyAsync(algorithm, publicKey, signature, data) {\n  const curveMap = {\n    'ES256': 'P-256',\n    'ES384': 'P-384',\n    'ES512': 'P-521',\n  };\n  const hashMap = {\n    'ES256': 'SHA-256',\n    'ES384': 'SHA-384',\n    'ES512': 'SHA-512',\n  };\n  \n  const namedCurve = curveMap[algorithm];\n  const hashName = hashMap[algorithm];\n  \n  if (!namedCurve) {\n    throw new Error(`Unsupported algorithm: ${algorithm}`);\n  }\n\n  // Convert key to JWK format\n  const base64urlEncode = (bytes) => {\n    let binary = '';\n    for (let i = 0; i < bytes.length; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n  };\n\n  const jwk = {\n    kty: 'EC',\n    crv: namedCurve,\n    x: base64urlEncode(publicKey.x),\n    y: base64urlEncode(publicKey.y),\n  };\n\n  const key = await webcrypto.subtle.importKey(\n    'jwk',\n    jwk,\n    { name: 'ECDSA', namedCurve },\n    false,\n    ['verify']\n  );\n\n  return webcrypto.subtle.verify(\n    { name: 'ECDSA', hash: hashName },\n    key,\n    signature,\n    data\n  );\n}\n\n/**\n * Create private key from JWK (browser-compatible)\n * @param {Object} options - Key options\n * @param {Object} options.key - JWK key object\n * @returns {Object} - CryptoKey wrapper\n */\nfunction createPrivateKey(options) {\n  // Return a wrapper that will be used with the WebCrypto-based sign function\n  return {\n    _jwk: options.key,\n    _type: 'private',\n  };\n}\n\n/**\n * Create public key from JWK (browser-compatible)\n * @param {Object} options - Key options\n * @param {Object} options.key - JWK key object\n * @returns {Object} - CryptoKey wrapper\n */\nfunction createPublicKey(options) {\n  return {\n    _jwk: options.key,\n    _type: 'public',\n  };\n}\n\n/**\n * Convert any buffer-like to Uint8Array\n * Always creates a copy to avoid issues with views over shared buffers.\n */\nfunction toBytes(data) {\n  if (!data) {\n    return new Uint8Array(0);\n  }\n  \n  // For Uint8Array, create a copy to avoid view issues\n  if (data instanceof Uint8Array) {\n    const copy = new Uint8Array(data.length);\n    copy.set(data);\n    return copy;\n  }\n  \n  // For other ArrayBufferViews, copy the data\n  if (ArrayBuffer.isView(data)) {\n    const view = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    const copy = new Uint8Array(view.length);\n    copy.set(view);\n    return copy;\n  }\n  \n  if (data instanceof ArrayBuffer) {\n    return new Uint8Array(data);\n  }\n  \n  if (Array.isArray(data)) {\n    return new Uint8Array(data);\n  }\n  \n  // Handle Buffer-like objects with buffer property\n  if (data && typeof data === 'object' && 'buffer' in data && data.buffer instanceof ArrayBuffer) {\n    const view = new Uint8Array(data.buffer, data.byteOffset || 0, data.byteLength || data.length);\n    const copy = new Uint8Array(view.length);\n    copy.set(view);\n    return copy;\n  }\n  \n  return new Uint8Array(data);\n}\n\n/**\n * Sign data with a private key (browser-compatible)\n * @param {null} algorithm - Unused, algorithm is inferred from key\n * @param {Uint8Array} data - Data to sign\n * @param {Object} options - Signing options\n * @param {Object} options.key - Key wrapper from createPrivateKey\n * @param {string} options.dsaEncoding - Signature encoding\n * @returns {Promise<Uint8Array>} - Signature\n */\nasync function sign(algorithm, data, options) {\n  if (!options || !options.key) {\n    throw new Error('sign: options.key is required');\n  }\n  if (!options.key._jwk) {\n    throw new Error('sign: options.key._jwk is missing. Did you use createPrivateKey?');\n  }\n  \n  const jwk = options.key._jwk;\n  const namedCurve = jwk.crv;\n  \n  if (!namedCurve) {\n    throw new Error(`sign: JWK missing crv property. Got: ${JSON.stringify(Object.keys(jwk))}`);\n  }\n  \n  const hashMap = {\n    'P-256': 'SHA-256',\n    'P-384': 'SHA-384',\n    'P-521': 'SHA-512',\n  };\n  const hashName = hashMap[namedCurve];\n  \n  if (!hashName) {\n    throw new Error(`sign: Unsupported curve: ${namedCurve}`);\n  }\n  \n  // Ensure data is Uint8Array\n  const dataBytes = toBytes(data);\n  \n  const cryptoKey = await webcrypto.subtle.importKey(\n    'jwk',\n    jwk,\n    { name: 'ECDSA', namedCurve },\n    false,\n    ['sign']\n  );\n  \n  const signature = await webcrypto.subtle.sign(\n    { name: 'ECDSA', hash: hashName },\n    cryptoKey,\n    dataBytes\n  );\n  \n  return new Uint8Array(signature);\n}\n\n/**\n * Verify signature with a public key (browser-compatible)\n * @param {null} algorithm - Unused, algorithm is inferred from key\n * @param {Uint8Array} data - Data that was signed\n * @param {Object} options - Verification options\n * @param {Object} options.key - Key wrapper from createPublicKey\n * @param {string} options.dsaEncoding - Signature encoding\n * @param {Uint8Array} signature - Signature to verify\n * @returns {Promise<boolean>} - True if valid\n */\nasync function verify(algorithm, data, options, signature) {\n  if (!options || !options.key) {\n    throw new Error('verify: options.key is required');\n  }\n  if (!options.key._jwk) {\n    throw new Error('verify: options.key._jwk is missing. Did you use createPublicKey?');\n  }\n  \n  const jwk = options.key._jwk;\n  const namedCurve = jwk.crv;\n  \n  if (!namedCurve) {\n    throw new Error(`verify: JWK missing crv property. Got: ${JSON.stringify(Object.keys(jwk))}`);\n  }\n  \n  const hashMap = {\n    'P-256': 'SHA-256',\n    'P-384': 'SHA-384',\n    'P-521': 'SHA-512',\n  };\n  const hashName = hashMap[namedCurve];\n  \n  if (!hashName) {\n    throw new Error(`verify: Unsupported curve: ${namedCurve}`);\n  }\n  \n  // Ensure data and signature are Uint8Arrays\n  const dataBytes = toBytes(data);\n  const sigBytes = toBytes(signature);\n  \n  const cryptoKey = await webcrypto.subtle.importKey(\n    'jwk',\n    jwk,\n    { name: 'ECDSA', namedCurve },\n    false,\n    ['verify']\n  );\n  \n  const result = await webcrypto.subtle.verify(\n    { name: 'ECDSA', hash: hashName },\n    cryptoKey,\n    sigBytes,\n    dataBytes\n  );\n  \n  return result;\n}\n\n/**\n * Generate key pair synchronously (browser-compatible wrapper)\n * Note: This is async in browser but returns a promise\n */\nfunction generateKeyPairSync(type, options) {\n  throw new Error('generateKeyPairSync not available in browser. Use generateKeyPair() async version.');\n}\n\n// Export browser-compatible crypto module\nexport default {\n  randomBytes,\n  createHash,\n  createPrivateKey,\n  createPublicKey,\n  sign,\n  verify,\n  generateKeyPair: generateKeyPairAsync,\n  generateKeyPairSync,\n  hashAsync,\n  subtle: webcrypto?.subtle,\n};\n\nexport { \n  randomBytes, \n  createHash, \n  createPrivateKey,\n  createPublicKey,\n  sign,\n  verify,\n  hashAsync, \n  generateKeyPairAsync, \n  signAsync, \n  verifyAsync,\n  generateKeyPairSync,\n};\n\n", "/**\n * Minimal COSE Sign1 Implementation\n * \n * This module provides COSE_Sign1 signing and verification using\n * native Maps for headers (no object API weirdness).\n * \n * References:\n * - RFC 9052: COSE Structures and Process\n * - RFC 9053: COSE Algorithms\n */\n\nimport * as cbor from 'cbor2';\nimport crypto from 'node:crypto';\n\n/**\n * COSE_Sign1 tag value (RFC 9052)\n */\nexport const COSE_Sign1_Tag = 18;\n\n/**\n * COSE Header Parameters (RFC 9052 Section 3.1)\n */\nexport const HeaderParam = {\n  Algorithm: 1,\n  Critical: 2,\n  ContentType: 3,\n  KeyId: 4,\n  IV: 5,\n  PartialIV: 6,\n  CounterSignature: 7,\n  CounterSignature0: 9,\n  X5Bag: 32,\n  X5Chain: 33,\n  X5T: 34,\n  X5U: 35,\n};\n\n/**\n * COSE Algorithms (RFC 9053)\n */\nexport const Alg = {\n  ES256: -7,   // ECDSA w/ SHA-256\n  ES384: -35,  // ECDSA w/ SHA-384\n  ES512: -36,  // ECDSA w/ SHA-512\n};\n\n/**\n * Default CBOR decode options.\n * Uses preferMap: true to ensure CBOR maps decode as JavaScript Maps.\n */\nconst cborDecodeOptions = {\n  preferMap: true,\n};\n\n/**\n * Algorithm metadata\n */\nconst AlgInfo = {\n  [Alg.ES256]: { name: 'ES256', curve: 'P-256', hash: 'sha256', sigSize: 64 },\n  [Alg.ES384]: { name: 'ES384', curve: 'P-384', hash: 'sha384', sigSize: 96 },\n  [Alg.ES512]: { name: 'ES512', curve: 'P-521', hash: 'sha512', sigSize: 132 },\n};\n\n/**\n * Creates a copy of byte data to avoid issues with views over shared buffers\n */\nfunction copyBytes(data) {\n  if (!data || data.length === 0) {\n    return data;\n  }\n  if (data instanceof Uint8Array) {\n    const copy = new Uint8Array(data.length);\n    copy.set(data);\n    return copy;\n  }\n  if (ArrayBuffer.isView(data)) {\n    const view = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    const copy = new Uint8Array(view.length);\n    copy.set(view);\n    return copy;\n  }\n  return data;\n}\n\n/**\n * Creates the Sig_structure for signing/verification\n * \n * Sig_structure = [\n *   context : \"Signature1\",\n *   body_protected : bstr,\n *   external_aad : bstr,\n *   payload : bstr\n * ]\n * \n * @param {Uint8Array} protectedHeader - Encoded protected header\n * @param {Uint8Array} payload - The payload\n * @param {Uint8Array} [externalAad] - External additional authenticated data\n * @returns {Uint8Array} - CBOR-encoded Sig_structure\n */\nfunction createSigStructure(protectedHeader, payload, externalAad = new Uint8Array(0)) {\n  const structure = [\n    'Signature1',\n    protectedHeader,\n    externalAad,\n    payload,\n  ];\n  return cbor.encode(structure);\n}\n\n/**\n * Signs a payload and creates a COSE_Sign1 message\n * \n * @param {Object} options - Signing options\n * @param {Map} options.protectedHeader - Protected header parameters (must include Algorithm)\n * @param {Map} [options.unprotectedHeader] - Unprotected header parameters\n * @param {Uint8Array} options.payload - The payload to sign\n * @param {Object} options.key - The signing key\n * @param {Uint8Array} options.key.d - Private key 'd' component\n * @param {Uint8Array} options.key.x - Public key 'x' coordinate\n * @param {Uint8Array} options.key.y - Public key 'y' coordinate\n * @param {Uint8Array} [options.externalAad] - External additional authenticated data\n * @returns {Promise<Uint8Array>} - COSE_Sign1 message (tagged)\n */\nexport async function sign(options) {\n  const {\n    protectedHeader,\n    unprotectedHeader = new Map(),\n    payload,\n    key,\n    externalAad = new Uint8Array(0),\n  } = options;\n\n  // Validate inputs\n  if (!(protectedHeader instanceof Map)) {\n    throw new TypeError('protectedHeader must be a Map');\n  }\n  if (!(unprotectedHeader instanceof Map)) {\n    throw new TypeError('unprotectedHeader must be a Map');\n  }\n  if (!payload) {\n    throw new Error('payload is required');\n  }\n  if (!key || !key.d || !key.x || !key.y) {\n    throw new Error('key must include d, x, and y components');\n  }\n\n  // Get algorithm from protected header\n  const alg = protectedHeader.get(HeaderParam.Algorithm);\n  if (alg === undefined) {\n    throw new Error('Algorithm (1) must be in protected header');\n  }\n\n  const algInfo = AlgInfo[alg];\n  if (!algInfo) {\n    throw new Error(`Unsupported algorithm: ${alg}`);\n  }\n\n  // Encode protected header\n  const protectedBytes = protectedHeader.size > 0 \n    ? cbor.encode(protectedHeader) \n    : new Uint8Array(0);\n\n  // Ensure payload is Uint8Array (not Buffer, which cbor2 encodes differently)\n  let payloadBytes;\n  if (Buffer.isBuffer(payload)) {\n    payloadBytes = new Uint8Array(payload.buffer, payload.byteOffset, payload.length);\n  } else if (payload instanceof Uint8Array) {\n    payloadBytes = payload;\n  } else {\n    payloadBytes = new Uint8Array(Buffer.from(payload));\n  }\n\n  // Create Sig_structure\n  const sigStructure = createSigStructure(protectedBytes, payloadBytes, externalAad);\n\n  // Sign\n  const signature = await signECDSA(sigStructure, key, algInfo);\n\n  // Build COSE_Sign1: [protected, unprotected, payload, signature]\n  const coseSign1 = [\n    protectedBytes,\n    unprotectedHeader,\n    payloadBytes,\n    signature,\n  ];\n\n  // Return tagged COSE_Sign1\n  return cbor.encode(new cbor.Tag(COSE_Sign1_Tag, coseSign1));\n}\n\n/**\n * Verifies a COSE_Sign1 message\n * \n * @param {Uint8Array} coseSign1 - The COSE_Sign1 message\n * @param {Object} key - The verification key\n * @param {Uint8Array} key.x - Public key 'x' coordinate\n * @param {Uint8Array} key.y - Public key 'y' coordinate\n * @param {Uint8Array} [externalAad] - External additional authenticated data\n * @returns {Promise<Uint8Array>} - The verified payload\n * @throws {Error} If verification fails\n */\nexport async function verify(coseSign1, key, externalAad = new Uint8Array(0)) {\n  if (!coseSign1) {\n    throw new Error('COSE_Sign1 message is required');\n  }\n  if (!key || !key.x || !key.y) {\n    throw new Error('key must include x and y components');\n  }\n\n  // Decode COSE_Sign1\n  const decoded = cbor.decode(coseSign1, cborDecodeOptions);\n  \n  // Handle tagged or untagged\n  const structure = decoded instanceof cbor.Tag ? decoded.contents : decoded;\n  \n  if (!Array.isArray(structure) || structure.length !== 4) {\n    throw new Error('Invalid COSE_Sign1 structure');\n  }\n\n  const [protectedBytesRaw, , payloadRaw, signatureRaw] = structure;\n\n  // Create copies of byte arrays to avoid issues with views over shared buffers\n  const protectedBytes = copyBytes(protectedBytesRaw);\n  const payload = copyBytes(payloadRaw);\n  const signature = copyBytes(signatureRaw);\n\n  // Decode protected header to get algorithm\n  let protectedHeader = new Map();\n  if (protectedBytes && protectedBytes.length > 0) {\n    const decodedProtected = cbor.decode(protectedBytes, cborDecodeOptions);\n    protectedHeader = decodedProtected instanceof Map ? decodedProtected : new Map(Object.entries(decodedProtected));\n  }\n\n  const alg = protectedHeader.get(HeaderParam.Algorithm);\n  if (alg === undefined) {\n    throw new Error('Algorithm not found in protected header');\n  }\n\n  const algInfo = AlgInfo[alg];\n  if (!algInfo) {\n    throw new Error(`Unsupported algorithm: ${alg}`);\n  }\n\n  // Create Sig_structure\n  const sigStructure = createSigStructure(protectedBytes, payload, externalAad);\n\n  // Verify signature\n  const isValid = await verifyECDSA(sigStructure, signature, key, algInfo);\n  \n  if (!isValid) {\n    throw new Error('Signature verification failed');\n  }\n\n  return payload;\n}\n\n/**\n * Decodes a COSE_Sign1 message and extracts its components\n * \n * @param {Uint8Array} coseSign1 - The COSE_Sign1 message\n * @returns {Object} - Decoded components\n */\nexport function decode(coseSign1) {\n  if (!coseSign1) {\n    throw new Error('COSE_Sign1 message is required');\n  }\n\n  const decoded = cbor.decode(coseSign1, cborDecodeOptions);\n  const structure = decoded instanceof cbor.Tag ? decoded.contents : decoded;\n  \n  if (!Array.isArray(structure) || structure.length !== 4) {\n    throw new Error('Invalid COSE_Sign1 structure');\n  }\n\n  const [protectedBytesRaw, unprotectedHeader, payloadRaw, signatureRaw] = structure;\n  \n  // Create copies of byte arrays to avoid issues with views over shared buffers\n  const protectedBytes = copyBytes(protectedBytesRaw);\n  const payload = copyBytes(payloadRaw);\n  const signature = copyBytes(signatureRaw);\n\n  // Decode protected header\n  let protectedHeader = new Map();\n  if (protectedBytes && protectedBytes.length > 0) {\n    const decodedHeader = cbor.decode(protectedBytes, cborDecodeOptions);\n    protectedHeader = decodedHeader instanceof Map \n      ? decodedHeader \n      : new Map(Object.entries(decodedHeader).map(([k, v]) => [Number(k), v]));\n  }\n\n  // Ensure unprotected header is a Map\n  let unprotected = unprotectedHeader;\n  if (!(unprotected instanceof Map)) {\n    unprotected = new Map(Object.entries(unprotected || {}).map(([k, v]) => [Number(k), v]));\n  }\n\n  return {\n    protectedHeader,\n    unprotectedHeader: unprotected,\n    payload,\n    signature,\n  };\n}\n\n/**\n * ECDSA signing using Node.js crypto\n */\nasync function signECDSA(data, key, algInfo) {\n  const jwk = {\n    kty: 'EC',\n    crv: algInfo.curve,\n    d: Buffer.from(key.d).toString('base64url'),\n    x: Buffer.from(key.x).toString('base64url'),\n    y: Buffer.from(key.y).toString('base64url'),\n  };\n\n  const privateKey = crypto.createPrivateKey({ key: jwk, format: 'jwk' });\n  const signature = crypto.sign(null, data, { key: privateKey, dsaEncoding: 'ieee-p1363' });\n  \n  return new Uint8Array(signature);\n}\n\n/**\n * ECDSA verification using Node.js crypto\n */\nasync function verifyECDSA(data, signature, key, algInfo) {\n  // Ensure we have a copy of the signature to avoid view issues\n  let sigBytes;\n  if (signature instanceof Uint8Array) {\n    sigBytes = new Uint8Array(signature.length);\n    sigBytes.set(signature);\n  } else if (ArrayBuffer.isView(signature)) {\n    sigBytes = new Uint8Array(signature.buffer, signature.byteOffset, signature.byteLength);\n    const copy = new Uint8Array(sigBytes.length);\n    copy.set(sigBytes);\n    sigBytes = copy;\n  } else {\n    sigBytes = new Uint8Array(Buffer.from(signature));\n  }\n  \n  const jwk = {\n    kty: 'EC',\n    crv: algInfo.curve,\n    x: Buffer.from(key.x).toString('base64url'),\n    y: Buffer.from(key.y).toString('base64url'),\n  };\n\n  const publicKey = crypto.createPublicKey({ key: jwk, format: 'jwk' });\n  const sigBuffer = Buffer.from(sigBytes);\n  \n  return crypto.verify(null, data, { key: publicKey, dsaEncoding: 'ieee-p1363' }, sigBuffer);\n}\n\n/**\n * Generates an EC key pair for COSE signing\n * \n * @param {number} [alg=Alg.ES256] - The algorithm identifier\n * @returns {Object} - { privateKey, publicKey }\n */\nexport function generateKeyPair(alg = Alg.ES256) {\n  const algInfo = AlgInfo[alg];\n  if (!algInfo) {\n    throw new Error(`Unsupported algorithm: ${alg}`);\n  }\n\n  const { privateKey, publicKey } = crypto.generateKeyPairSync('ec', {\n    namedCurve: algInfo.curve,\n  });\n\n  const privateJwk = privateKey.export({ format: 'jwk' });\n  const publicJwk = publicKey.export({ format: 'jwk' });\n\n  return {\n    privateKey: {\n      d: new Uint8Array(Buffer.from(privateJwk.d, 'base64url')),\n      x: new Uint8Array(Buffer.from(privateJwk.x, 'base64url')),\n      y: new Uint8Array(Buffer.from(privateJwk.y, 'base64url')),\n    },\n    publicKey: {\n      x: new Uint8Array(Buffer.from(publicJwk.x, 'base64url')),\n      y: new Uint8Array(Buffer.from(publicJwk.y, 'base64url')),\n    },\n  };\n}\n\n", "/**\n * SD-CWT (Selective Disclosure CBOR Web Token) Utilities\n * \n * This module provides convenience APIs for working with SD-CWT structures,\n * including \"To Be Redacted\" tagging as defined in draft-ietf-spice-sd-cwt.\n * \n * References:\n * - draft-ietf-spice-sd-cwt (SD-CWT specification)\n * - RFC 8949 (CBOR)\n */\n\nimport * as cbor from 'cbor2';\nimport crypto from 'node:crypto';\n\n/**\n * Maximum recommended depth for nested structures (per spec section 6.5)\n */\nexport const MAX_DEPTH = 16;\n\n/**\n * CBOR Tags defined for SD-CWT\n */\nexport const Tag = {\n  /** Tag 58: Wraps claims intended to be redacted (used in pre-issuance) */\n  ToBeRedacted: 58,\n  /** Tag 60: Wraps a redacted array element (contains hash) */\n  RedactedClaimElement: 60,\n  /** Tag 61: Wraps a decoy value to be inserted */\n  ToBeDecoy: 61,\n};\n\n/**\n * CBOR Simple Values defined for SD-CWT\n */\nexport const SimpleValue = {\n  /** Simple value 59: Map key for array of redacted claim key hashes */\n  RedactedKeys: 59,\n};\n\n/**\n * SD-CWT Header Parameters\n */\nexport const HeaderParam = {\n  /** alg: Algorithm */\n  Alg: 1,\n  /** kid: Key identifier */\n  Kid: 4,\n  /** kcwt: Key Binding CWT (contains the SD-CWT in SD-KBT) */\n  Kcwt: 13,\n  /** typ: Content type */\n  Typ: 16,\n  /** sd_claims: Array of selectively disclosed claims */\n  SdClaims: 17,\n  /** sd_alg: Hash algorithm used for redaction */\n  SdAlg: 18,\n  /** sd_aead_encrypted_claims */\n  SdAeadEncryptedClaims: 19,\n  /** sd_aead */\n  SdAead: 20,\n};\n\n/**\n * CWT Claim Keys (from RFC 8392)\n */\nexport const ClaimKey = {\n  /** iss: Issuer */\n  Iss: 1,\n  /** sub: Subject */\n  Sub: 2,\n  /** aud: Audience */\n  Aud: 3,\n  /** exp: Expiration time */\n  Exp: 4,\n  /** nbf: Not before */\n  Nbf: 5,\n  /** iat: Issued at */\n  Iat: 6,\n  /** cti: CWT ID */\n  Cti: 7,\n  /** cnf: Confirmation (from RFC 8747) */\n  Cnf: 8,\n  /** cnonce: Client nonce */\n  Cnonce: 39,\n};\n\n/**\n * Media types for SD-CWT\n */\nexport const MediaType = {\n  SdCwt: 'application/sd-cwt',\n  KbCwt: 'application/kb+cwt',\n};\n\n/**\n * Hash algorithms for SD-CWT\n */\nexport const SdAlg = {\n  SHA256: -16,\n};\n\n/**\n * Default CBOR decode options for SD-CWT.\n * Uses preferMap: true to ensure CBOR maps decode as JavaScript Maps.\n */\nexport const cborDecodeOptions = {\n  preferMap: true,\n};\n\n/**\n * Creates a \"To Be Redacted\" tagged value.\n * \n * This tag indicates to the Issuer that the wrapped value should be\n * converted to a redacted claim during issuance.\n * \n * @param {any} value - The value to wrap (can be a map key, map value, or array element)\n * @returns {cbor.Tag} A CBOR Tag with tag number 58 containing the value\n * \n * @example\n * // Mark a claim to be redactable\n * const claims = new Map([\n *   [toBeRedacted(1), \"sensitive-value\"],  // key 1 will be redactable\n *   [2, \"public-value\"]\n * ]);\n */\nexport function toBeRedacted(value) {\n  return new cbor.Tag(Tag.ToBeRedacted, value);\n}\n\n/**\n * Creates a \"To Be Decoy\" tagged value.\n * \n * This tag indicates to the Issuer that a decoy should be inserted\n * at this position. The value is a positive integer indicating\n * how many decoys to insert.\n * \n * @param {number} count - Number of decoys to insert (positive integer)\n * @returns {cbor.Tag} A CBOR Tag with tag number 61 containing the count\n */\nexport function toBeDecoy(count) {\n  if (!Number.isInteger(count) || count < 1) {\n    throw new Error('Decoy count must be a positive integer');\n  }\n  return new cbor.Tag(Tag.ToBeDecoy, count);\n}\n\n/**\n * Creates a Redacted Claim Element tag.\n * \n * This wraps a hash that represents a redacted element in an array.\n * Used in issued SD-CWTs to represent array elements that have been redacted.\n * \n * @param {Uint8Array|Buffer} hash - The hash of the salted disclosure\n * @returns {cbor.Tag} A CBOR Tag with tag number 60 containing the hash\n */\nexport function redactedClaimElement(hash) {\n  const hashBytes = hash instanceof Uint8Array ? hash : new Uint8Array(hash);\n  return new cbor.Tag(Tag.RedactedClaimElement, hashBytes);\n}\n\n/**\n * Creates a CBOR simple value for use as a map key.\n * \n * @param {number} value - The simple value number\n * @returns {cbor.Simple} A CBOR simple value\n */\nexport function simple(value) {\n  return new cbor.Simple(value);\n}\n\n/**\n * Returns the CBOR simple value used as map key for redacted claim keys array\n * \n * @returns {cbor.Simple} Simple value 59\n */\nexport function redactedKeysKey() {\n  return new cbor.Simple(SimpleValue.RedactedKeys);\n}\n\n/**\n * Checks if a value is a \"To Be Redacted\" tagged value\n * \n * @param {any} value - The value to check\n * @returns {boolean} True if the value is tagged with tag 58\n */\nexport function isToBeRedacted(value) {\n  return value instanceof cbor.Tag && value.tag === Tag.ToBeRedacted;\n}\n\n/**\n * Checks if a value is a \"Redacted Claim Element\" tagged value\n * \n * @param {any} value - The value to check\n * @returns {boolean} True if the value is tagged with tag 60\n */\nexport function isRedactedClaimElement(value) {\n  return value instanceof cbor.Tag && value.tag === Tag.RedactedClaimElement;\n}\n\n/**\n * Checks if a value is a \"To Be Decoy\" tagged value\n * \n * @param {any} value - The value to check\n * @returns {boolean} True if the value is tagged with tag 61\n */\nexport function isToBeDecoy(value) {\n  return value instanceof cbor.Tag && value.tag === Tag.ToBeDecoy;\n}\n\n/**\n * Checks if a value is the redacted keys simple value (59)\n * \n * @param {any} value - The value to check\n * @returns {boolean} True if the value is simple(59)\n */\nexport function isRedactedKeysKey(value) {\n  return value instanceof cbor.Simple && value.value === SimpleValue.RedactedKeys;\n}\n\n/**\n * Extracts the contents from a CBOR tag\n * \n * @param {cbor.Tag} tag - The CBOR tag\n * @returns {any} The contents of the tag\n */\nexport function getTagContents(tag) {\n  if (!(tag instanceof cbor.Tag)) {\n    throw new Error('Value is not a CBOR tag');\n  }\n  return tag.contents;\n}\n\n/**\n * Generates a random 128-bit salt for disclosures\n * \n * @returns {Uint8Array} A 16-byte random salt\n */\nexport function generateSalt() {\n  return new Uint8Array(crypto.randomBytes(16));\n}\n\n/**\n * Creates a salted disclosure for a claim key\n * \n * Format: [salt, value, claimName]\n * \n * @param {Uint8Array} salt - 128-bit salt\n * @param {any} value - The claim value\n * @param {string|number} claimName - The claim name/key\n * @returns {Uint8Array} CBOR-encoded salted disclosure\n */\nexport function createSaltedDisclosure(salt, value, claimName) {\n  const disclosure = [salt, value, claimName];\n  return cbor.encode(disclosure);\n}\n\n/**\n * Creates a salted disclosure for an array element\n * \n * Format: [salt, value] (no claim name for array elements)\n * \n * @param {Uint8Array} salt - 128-bit salt\n * @param {any} value - The element value\n * @returns {Uint8Array} CBOR-encoded salted disclosure\n */\nexport function createArrayElementDisclosure(salt, value) {\n  const disclosure = [salt, value];\n  return cbor.encode(disclosure);\n}\n\n/**\n * Computes the hash of a disclosure\n * \n * @param {Uint8Array} disclosure - The CBOR-encoded disclosure\n * @param {string} [algorithm='sha256'] - Hash algorithm to use\n * @returns {Uint8Array} The hash digest\n */\nexport function hashDisclosure(disclosure, algorithm = 'sha256') {\n  const hash = crypto.createHash(algorithm);\n  hash.update(disclosure);\n  return new Uint8Array(hash.digest());\n}\n\n/**\n * Options for processing redacted claims\n * @typedef {Object} ProcessOptions\n * @property {boolean} [strict=false] - If true, throw error if depth exceeds MAX_DEPTH (16)\n * @property {string} [hashAlg='sha256'] - Hash algorithm to use\n */\n\n/**\n * Checks and enforces depth limit\n * @param {number} depth - Current depth\n * @param {boolean} strict - Whether to enforce strict depth limit\n */\nfunction checkDepth(depth, strict) {\n  if (strict && depth > MAX_DEPTH) {\n    throw new Error(`Depth ${depth} exceeds maximum allowed depth of ${MAX_DEPTH}`);\n  }\n}\n\n/**\n * Processes a value recursively, handling maps, arrays, and CBOR tags\n * @param {any} value - The value to process\n * @param {string} hashAlg - Hash algorithm\n * @param {boolean} strict - Enforce depth limit\n * @param {number} depth - Current depth\n * @returns {{value: any, disclosures: Uint8Array[]}} Processed value and disclosures\n */\nfunction processValueRecursive(value, hashAlg, strict, depth) {\n  checkDepth(depth, strict);\n  \n  if (value instanceof Map) {\n    return processMapInternal(value, hashAlg, strict, depth);\n  } else if (Array.isArray(value)) {\n    return processArrayInternal(value, hashAlg, strict, depth);\n  } else if (value instanceof cbor.Tag) {\n    // Handle non-SD-CWT CBOR tags - process their contents recursively\n    if (!isToBeRedacted(value) && !isToBeDecoy(value) && !isRedactedClaimElement(value)) {\n      const { value: processedContents, disclosures } = processValueRecursive(\n        value.contents, hashAlg, strict, depth + 1\n      );\n      return { value: new cbor.Tag(value.tag, processedContents), disclosures };\n    }\n  }\n  return { value, disclosures: [] };\n}\n\n/**\n * Internal implementation for processing maps with depth tracking\n */\nfunction processMapInternal(claims, hashAlg, strict, depth) {\n  checkDepth(depth, strict);\n  \n  const resultClaims = new Map();\n  const disclosures = [];\n  const redactedKeyHashes = [];\n\n  for (const [key, value] of claims) {\n    if (isToBeRedacted(key)) {\n      // This is a claim marked for redaction\n      const actualKey = getTagContents(key);\n      const salt = generateSalt();\n      \n      // Process the value before creating disclosure (to handle nested structures)\n      const { value: processedValue, disclosures: nestedDisclosures } = processValueRecursive(\n        value, hashAlg, strict, depth + 1\n      );\n      disclosures.push(...nestedDisclosures);\n      \n      const disclosure = createSaltedDisclosure(salt, processedValue, actualKey);\n      const hash = hashDisclosure(disclosure, hashAlg);\n      \n      disclosures.push(disclosure);\n      redactedKeyHashes.push(hash);\n    } else if (isToBeDecoy(key)) {\n      // Insert decoy hashes\n      const count = getTagContents(key);\n      for (let i = 0; i < count; i++) {\n        const salt = generateSalt();\n        const decoyDisclosure = cbor.encode([salt]); // Decoy is just a salt\n        const hash = hashDisclosure(decoyDisclosure, hashAlg);\n        redactedKeyHashes.push(hash);\n      }\n    } else {\n      // Regular claim, pass through with recursive processing\n      const { value: processedValue, disclosures: nestedDisclosures } = processValueRecursive(\n        value, hashAlg, strict, depth + 1\n      );\n      resultClaims.set(key, processedValue);\n      disclosures.push(...nestedDisclosures);\n    }\n  }\n\n  // Add redacted keys array if there are any\n  if (redactedKeyHashes.length > 0) {\n    resultClaims.set(redactedKeysKey(), redactedKeyHashes);\n  }\n\n  return { value: resultClaims, claims: resultClaims, disclosures };\n}\n\n/**\n * Internal implementation for processing arrays with depth tracking\n */\nfunction processArrayInternal(array, hashAlg, strict, depth) {\n  checkDepth(depth, strict);\n  \n  const resultArray = [];\n  const disclosures = [];\n\n  for (const element of array) {\n    if (isToBeRedacted(element)) {\n      // This element should be redacted\n      const actualValue = getTagContents(element);\n      const salt = generateSalt();\n      \n      // Process the value before creating disclosure (to handle nested structures)\n      const { value: processedValue, disclosures: nestedDisclosures } = processValueRecursive(\n        actualValue, hashAlg, strict, depth + 1\n      );\n      disclosures.push(...nestedDisclosures);\n      \n      const disclosure = createArrayElementDisclosure(salt, processedValue);\n      const hash = hashDisclosure(disclosure, hashAlg);\n      \n      disclosures.push(disclosure);\n      resultArray.push(redactedClaimElement(hash));\n    } else if (isToBeDecoy(element)) {\n      // Insert decoy elements\n      const count = getTagContents(element);\n      for (let i = 0; i < count; i++) {\n        const salt = generateSalt();\n        const decoyDisclosure = cbor.encode([salt]);\n        const hash = hashDisclosure(decoyDisclosure, hashAlg);\n        resultArray.push(redactedClaimElement(hash));\n      }\n    } else {\n      // Regular element - process recursively\n      const { value: processedValue, disclosures: nestedDisclosures } = processValueRecursive(\n        element, hashAlg, strict, depth + 1\n      );\n      resultArray.push(processedValue);\n      disclosures.push(...nestedDisclosures);\n    }\n  }\n\n  return { value: resultArray, array: resultArray, disclosures };\n}\n\n/**\n * Processes a claims map and converts \"To Be Redacted\" tagged keys\n * into redacted claims structure.\n * \n * This transforms:\n * {\n *   58(500): \"secret\",\n *   501: \"public\"\n * }\n * \n * Into:\n * {\n *   501: \"public\",\n *   simple(59): [<hash-of-disclosure-for-500>]\n * }\n * \n * Plus returns the disclosures for the redacted claims.\n * \n * @param {Map} claims - Map with potentially tagged keys\n * @param {string|ProcessOptions} [hashAlgOrOptions='sha256'] - Hash algorithm or options object\n * @returns {{claims: Map, disclosures: Uint8Array[]}} Processed claims and disclosures\n */\nexport function processToBeRedacted(claims, hashAlgOrOptions = 'sha256') {\n  const { hashAlg, strict } = normalizeOptions(hashAlgOrOptions);\n  const result = processMapInternal(claims, hashAlg, strict, 1);\n  return { claims: result.claims, disclosures: result.disclosures };\n}\n\n/**\n * Normalizes options parameter to extract hashAlg and strict\n */\nfunction normalizeOptions(hashAlgOrOptions) {\n  if (typeof hashAlgOrOptions === 'string') {\n    return { hashAlg: hashAlgOrOptions, strict: false };\n  }\n  return {\n    hashAlg: hashAlgOrOptions.hashAlg || 'sha256',\n    strict: hashAlgOrOptions.strict || false,\n  };\n}\n\n/**\n * Processes an array and converts \"To Be Redacted\" tagged elements\n * into redacted claim elements.\n * \n * @param {Array} array - Array with potentially tagged elements\n * @param {string|ProcessOptions} [hashAlgOrOptions='sha256'] - Hash algorithm or options object\n * @returns {{array: Array, disclosures: Uint8Array[]}} Processed array and disclosures\n */\nexport function processArrayToBeRedacted(array, hashAlgOrOptions = 'sha256') {\n  const { hashAlg, strict } = normalizeOptions(hashAlgOrOptions);\n  const result = processArrayInternal(array, hashAlg, strict, 1);\n  return { array: result.array, disclosures: result.disclosures };\n}\n\n/**\n * Decodes a disclosure and returns its components.\n * Uses preferMap: true to ensure any CBOR maps in the disclosure\n * are decoded as JavaScript Maps.\n * \n * @param {Uint8Array} disclosure - CBOR-encoded disclosure\n * @returns {{salt: Uint8Array, value: any, claimName?: string|number}} Decoded components\n */\nexport function decodeDisclosure(disclosure) {\n  const decoded = cbor.decode(disclosure, cborDecodeOptions);\n  \n  if (!Array.isArray(decoded)) {\n    throw new Error('Invalid disclosure format: expected array');\n  }\n\n  if (decoded.length === 2) {\n    // Array element disclosure: [salt, value]\n    return {\n      salt: decoded[0],\n      value: decoded[1],\n    };\n  } else if (decoded.length === 3) {\n    // Claim key disclosure: [salt, value, claimName]\n    return {\n      salt: decoded[0],\n      value: decoded[1],\n      claimName: decoded[2],\n    };\n  } else if (decoded.length === 1) {\n    // Decoy: [salt]\n    return {\n      salt: decoded[0],\n      value: undefined,\n      isDecoy: true,\n    };\n  }\n\n  throw new Error(`Invalid disclosure format: unexpected length ${decoded.length}`);\n}\n\n/**\n * Compares two Uint8Arrays for equality\n * \n * @param {Uint8Array} a - First array\n * @param {Uint8Array} b - Second array\n * @returns {boolean} True if arrays are equal\n */\nfunction bytesEqual(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\n/**\n * Builds a lookup map from disclosure hash to decoded disclosure\n * \n * @param {Uint8Array[]} disclosures - Array of CBOR-encoded disclosures\n * @param {string} [hashAlg='sha256'] - Hash algorithm used\n * @returns {Map<string, {hash: Uint8Array, decoded: object}>} Lookup map keyed by hex hash\n */\nfunction buildDisclosureLookup(disclosures, hashAlg = 'sha256') {\n  const lookup = new Map();\n  for (const disclosure of disclosures) {\n    const hash = hashDisclosure(disclosure, hashAlg);\n    const decoded = decodeDisclosure(disclosure);\n    // Use hex string as key for easy Map lookup\n    const hexKey = Buffer.from(hash).toString('hex');\n    lookup.set(hexKey, { hash, decoded, disclosure });\n  }\n  return lookup;\n}\n\n/**\n * Options for reconstructing claims\n * @typedef {Object} ReconstructOptions\n * @property {boolean} [strict=false] - If true, throw error if depth exceeds MAX_DEPTH (16)\n * @property {string} [hashAlg='sha256'] - Hash algorithm to use\n */\n\n/**\n * Reconstructs a value recursively, handling maps, arrays, and CBOR tags\n * @param {any} value - The value to reconstruct\n * @param {Map} lookup - Disclosure lookup map\n * @param {boolean} strict - Enforce depth limit\n * @param {number} depth - Current depth\n * @returns {{value: any, redactedHashes: Uint8Array[]}} Reconstructed value and remaining redacted hashes\n */\nfunction reconstructValueRecursive(value, lookup, strict, depth) {\n  checkDepth(depth, strict);\n  \n  if (value instanceof Map) {\n    const result = reconstructMapInternal(value, lookup, strict, depth);\n    return { value: result.claims, redactedHashes: result.redactedKeys };\n  } else if (Array.isArray(value)) {\n    const result = reconstructArrayRecursive(value, lookup, strict, depth);\n    return { value: result.array, redactedHashes: result.redactedElements };\n  } else if (value instanceof cbor.Tag) {\n    // Handle non-SD-CWT CBOR tags - reconstruct their contents recursively\n    if (!isRedactedClaimElement(value)) {\n      const { value: reconstructedContents, redactedHashes } = reconstructValueRecursive(\n        value.contents, lookup, strict, depth + 1\n      );\n      return { value: new cbor.Tag(value.tag, reconstructedContents), redactedHashes };\n    }\n  }\n  return { value, redactedHashes: [] };\n}\n\n/**\n * Reconstructs claims from a redacted map and disclosures.\n * \n * This is the inverse of processToBeRedacted. It takes a redacted claims map\n * (with simple(59) keys containing hashes) and the disclosures, then\n * reconstructs the original claims by matching disclosure hashes.\n * \n * @param {Map} redactedClaims - The redacted claims map\n * @param {Uint8Array[]} disclosures - Array of CBOR-encoded disclosures to apply\n * @param {string|ReconstructOptions} [hashAlgOrOptions='sha256'] - Hash algorithm or options object\n * @returns {{claims: Map, redactedKeys: Uint8Array[]}} Reconstructed claims and remaining redacted key hashes\n */\nexport function reconstructClaims(redactedClaims, disclosures, hashAlgOrOptions = 'sha256') {\n  const { hashAlg, strict } = normalizeOptions(hashAlgOrOptions);\n  const lookup = buildDisclosureLookup(disclosures, hashAlg);\n  return reconstructMapInternal(redactedClaims, lookup, strict, 1);\n}\n\n/**\n * Internal recursive implementation for reconstructClaims with depth tracking\n */\nfunction reconstructMapInternal(redactedClaims, lookup, strict, depth) {\n  checkDepth(depth, strict);\n  \n  const resultClaims = new Map();\n  const remainingRedactedHashes = [];\n\n  // First, find and process the redacted keys array (simple(59) key)\n  let redactedKeyHashes = null;\n  for (const [key, value] of redactedClaims) {\n    if (isRedactedKeysKey(key)) {\n      redactedKeyHashes = value;\n    } else {\n      // Copy non-redacted-keys entries, recursively processing nested structures\n      const { value: processedValue, redactedHashes } = reconstructValueRecursive(\n        value, lookup, strict, depth + 1\n      );\n      resultClaims.set(key, processedValue);\n      remainingRedactedHashes.push(...redactedHashes);\n    }\n  }\n\n  // Process redacted key hashes - match against disclosures\n  if (redactedKeyHashes) {\n    for (const hash of redactedKeyHashes) {\n      const hashBytes = hash instanceof Uint8Array ? hash : new Uint8Array(hash);\n      const hexKey = Buffer.from(hashBytes).toString('hex');\n      const entry = lookup.get(hexKey);\n      \n      if (entry && entry.decoded.claimName !== undefined) {\n        // Found matching disclosure - restore the claim\n        const { value: restoredValue, redactedHashes } = reconstructValueRecursive(\n          entry.decoded.value, lookup, strict, depth + 1\n        );\n        remainingRedactedHashes.push(...redactedHashes);\n        resultClaims.set(entry.decoded.claimName, restoredValue);\n      } else {\n        // No matching disclosure - keep as redacted\n        remainingRedactedHashes.push(hashBytes);\n      }\n    }\n  }\n\n  return { claims: resultClaims, redactedKeys: remainingRedactedHashes };\n}\n\n/**\n * Reconstructs an array from redacted elements and disclosures.\n * \n * @param {Array} redactedArray - Array containing redacted claim elements (tag 60)\n * @param {Uint8Array[]} disclosures - Array of CBOR-encoded disclosures\n * @param {string|ReconstructOptions} [hashAlgOrOptions='sha256'] - Hash algorithm or options object\n * @returns {{array: Array, redactedElements: Uint8Array[]}} Reconstructed array and remaining redacted hashes\n */\nexport function reconstructArray(redactedArray, disclosures, hashAlgOrOptions = 'sha256') {\n  const { hashAlg, strict } = normalizeOptions(hashAlgOrOptions);\n  const lookup = buildDisclosureLookup(disclosures, hashAlg);\n  return reconstructArrayRecursive(redactedArray, lookup, strict, 1);\n}\n\n/**\n * Internal recursive implementation for reconstructArray with depth tracking\n */\nfunction reconstructArrayRecursive(redactedArray, lookup, strict, depth) {\n  checkDepth(depth, strict);\n  \n  const resultArray = [];\n  const remainingRedactedHashes = [];\n\n  for (const element of redactedArray) {\n    if (isRedactedClaimElement(element)) {\n      // This is a redacted element - try to find matching disclosure\n      const hashBytes = element.contents instanceof Uint8Array \n        ? element.contents \n        : new Uint8Array(element.contents);\n      const hexKey = Buffer.from(hashBytes).toString('hex');\n      const entry = lookup.get(hexKey);\n      \n      if (entry && entry.decoded.claimName === undefined && !entry.decoded.isDecoy) {\n        // Found matching array element disclosure - restore the value\n        const { value: restoredValue, redactedHashes } = reconstructValueRecursive(\n          entry.decoded.value, lookup, strict, depth + 1\n        );\n        remainingRedactedHashes.push(...redactedHashes);\n        resultArray.push(restoredValue);\n      } else {\n        // No matching disclosure (or is decoy) - keep as redacted\n        resultArray.push(element);\n        remainingRedactedHashes.push(hashBytes);\n      }\n    } else {\n      // Regular element - reconstruct recursively\n      const { value: processedValue, redactedHashes } = reconstructValueRecursive(\n        element, lookup, strict, depth + 1\n      );\n      resultArray.push(processedValue);\n      remainingRedactedHashes.push(...redactedHashes);\n    }\n  }\n\n  return { array: resultArray, redactedElements: remainingRedactedHashes };\n}\n\n/**\n * Result of validating claims for cleanliness\n * @typedef {Object} ValidationResult\n * @property {boolean} isClean - True if claims contain no SD-CWT artifacts\n * @property {string[]} issues - List of issues found\n */\n\n/**\n * Validates that claims are clean - containing no SD-CWT artifacts.\n * \n * A clean claims object should not contain:\n * - ToBeRedacted tags (tag 58) - should have been processed during issuance\n * - ToBeDecoy tags (tag 61) - should have been processed during issuance\n * - RedactedClaimElement tags (tag 60) - means some disclosures are missing\n * - Redacted keys (simple 59) - means some disclosures are missing\n * \n * @param {Map|Array|any} claims - The claims to validate\n * @param {Object} [options] - Validation options\n * @param {boolean} [options.strict=false] - If true, enforce depth limit\n * @param {boolean} [options.allowRedacted=false] - If true, allow redacted elements (tag 60 and simple 59)\n * @returns {ValidationResult} Validation result\n */\nexport function validateClaimsClean(claims, options = {}) {\n  const { strict = false, allowRedacted = false } = options;\n  const issues = [];\n  validateValueClean(claims, issues, strict, 1, allowRedacted, '');\n  return { isClean: issues.length === 0, issues };\n}\n\n/**\n * Internal recursive validation function\n */\nfunction validateValueClean(value, issues, strict, depth, allowRedacted, path) {\n  if (strict && depth > MAX_DEPTH) {\n    issues.push(`Depth ${depth} exceeds maximum at ${path || 'root'}`);\n    return;\n  }\n\n  if (value instanceof Map) {\n    for (const [key, val] of value) {\n      const keyPath = path ? `${path}.${String(key)}` : String(key);\n      \n      // Check for SD-CWT artifact keys\n      if (isToBeRedacted(key)) {\n        issues.push(`ToBeRedacted tag (58) found as key at ${keyPath}`);\n      }\n      if (isToBeDecoy(key)) {\n        issues.push(`ToBeDecoy tag (61) found as key at ${keyPath}`);\n      }\n      if (!allowRedacted && isRedactedKeysKey(key)) {\n        issues.push(`Redacted keys (simple 59) found at ${keyPath}`);\n      }\n      \n      // Check the value recursively\n      validateValueClean(val, issues, strict, depth + 1, allowRedacted, keyPath);\n    }\n  } else if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const elemPath = `${path}[${i}]`;\n      const elem = value[i];\n      \n      // Check for SD-CWT artifact elements\n      if (isToBeRedacted(elem)) {\n        issues.push(`ToBeRedacted tag (58) found at ${elemPath}`);\n      }\n      if (isToBeDecoy(elem)) {\n        issues.push(`ToBeDecoy tag (61) found at ${elemPath}`);\n      }\n      if (!allowRedacted && isRedactedClaimElement(elem)) {\n        issues.push(`RedactedClaimElement tag (60) found at ${elemPath}`);\n      }\n      \n      // Recursively check element (if not already a tag we reported)\n      if (!isToBeRedacted(elem) && !isToBeDecoy(elem) && !(isRedactedClaimElement(elem) && !allowRedacted)) {\n        validateValueClean(elem, issues, strict, depth + 1, allowRedacted, elemPath);\n      }\n    }\n  } else if (value instanceof cbor.Tag) {\n    const tagPath = path ? `${path}.<tag ${value.tag}>` : `<tag ${value.tag}>`;\n    \n    // Check for SD-CWT tags in unexpected places\n    if (isToBeRedacted(value)) {\n      issues.push(`ToBeRedacted tag (58) found at ${tagPath}`);\n    } else if (isToBeDecoy(value)) {\n      issues.push(`ToBeDecoy tag (61) found at ${tagPath}`);\n    } else if (!allowRedacted && isRedactedClaimElement(value)) {\n      issues.push(`RedactedClaimElement tag (60) found at ${tagPath}`);\n    } else {\n      // For other tags, check contents recursively\n      validateValueClean(value.contents, issues, strict, depth + 1, allowRedacted, tagPath);\n    }\n  }\n}\n\n/**\n * Asserts that claims are clean, throwing an error if not.\n * \n * @param {Map|Array|any} claims - The claims to validate\n * @param {Object} [options] - Validation options\n * @param {boolean} [options.strict=false] - If true, enforce depth limit\n * @param {boolean} [options.allowRedacted=false] - If true, allow redacted elements\n * @throws {Error} If claims contain SD-CWT artifacts\n */\nexport function assertClaimsClean(claims, options = {}) {\n  const result = validateClaimsClean(claims, options);\n  if (!result.isClean) {\n    throw new Error(`Claims contain SD-CWT artifacts:\\n${result.issues.join('\\n')}`);\n  }\n}\n\n", "/**\n * SD-CWT High-Level API\n * \n * This module provides a complete API for SD-CWT operations including:\n * - Key generation\n * - Issuer: Create SD-CWTs from claims with \"to be redacted\" structures\n * - Holder: Select which claims to disclose\n * - Verifier: Verify and reconstruct disclosed claims\n * \n * References:\n * - draft-ietf-spice-sd-cwt (SD-CWT specification)\n */\n\nimport * as cbor from 'cbor2';\nimport * as coseSign1 from './cose-sign1.js';\nimport * as sdCwt from './sd-cwt.js';\n\n// Re-export key utilities\nexport { toBeRedacted, toBeDecoy, MAX_DEPTH, validateClaimsClean, assertClaimsClean, ClaimKey, MediaType, HeaderParam } from './sd-cwt.js';\nexport { generateKeyPair, Algorithm } from './cose-sign1.js';\n\n/**\n * SD-CWT Issuer API\n * \n * Creates signed SD-CWT tokens from claims that may contain\n * \"to be redacted\" tagged values.\n */\nexport const Issuer = {\n  /**\n   * Creates a signed SD-CWT from claims with optional redactable values.\n   * \n   * Per spec Section 7: The payload MUST include a key confirmation element (cnf)\n   * for the Holder's public key. Either sub or redacted sub MUST be present.\n   * \n   * Claims can include:\n   * - Regular claims: included directly in the token\n   * - Redactable claims: wrapped with toBeRedacted(), stored as hashes with disclosures\n   * - Decoys: wrapped with toBeDecoy(count), adds fake redacted entries\n   * \n   * @param {Object} options - Issuance options\n   * @param {Map} options.claims - Claims map, MUST contain cnf (8) claim with holder's public key\n   * @param {Object} options.privateKey - Issuer's private key {d, x, y}\n   * @param {string} [options.algorithm='ES256'] - Signing algorithm\n   * @param {string} [options.hashAlgorithm='sha256'] - Hash algorithm for redactions\n   * @param {string|Buffer} [options.kid] - Key identifier\n   * @param {boolean} [options.strict=false] - If true, enforce max depth of 16 (per spec section 6.5)\n   * @returns {Promise<{token: Buffer, disclosures: Uint8Array[]}>} The signed SD-CWT and disclosures\n   * \n   * @example\n   * const claims = new Map([\n   *   [1, 'issuer.example'],                    // iss - public\n   *   [8, { 1: { 1: 2, -1: 1, -2: holderKey.x, -3: holderKey.y } }], // cnf - REQUIRED\n   *   [toBeRedacted(500), 'sensitive-value'],   // redactable claim\n   * ]);\n   * \n   * const { token, disclosures } = await Issuer.issue({\n   *   claims,\n   *   privateKey: issuerKey.privateKey,\n   * });\n   */\n  async issue({ claims, privateKey, algorithm = 'ES256', hashAlgorithm = 'sha256', kid, strict = false }) {\n    if (!(claims instanceof Map)) {\n      throw new Error('Claims must be a Map');\n    }\n\n    // Per spec Section 7: cnf (8) claim is REQUIRED and MUST NOT be redacted\n    // Check for cnf key (either plain or wrapped in toBeRedacted)\n    let hasCnf = false;\n    let cnfIsRedacted = false;\n    \n    for (const key of claims.keys()) {\n      if (key === sdCwt.ClaimKey.Cnf) {\n        hasCnf = true;\n        break;\n      }\n      if (sdCwt.isToBeRedacted(key) && sdCwt.getTagContents(key) === sdCwt.ClaimKey.Cnf) {\n        hasCnf = true;\n        cnfIsRedacted = true;\n        break;\n      }\n    }\n\n    if (!hasCnf) {\n      throw new Error('Claims MUST include cnf (8) claim with Holder\\'s public key (per spec Section 7)');\n    }\n\n    if (cnfIsRedacted) {\n      throw new Error('cnf (8) claim MUST NOT be redacted (per spec Section 7)');\n    }\n\n    // Process claims to handle toBeRedacted and toBeDecoy tags\n    const { claims: processedClaims, disclosures } = sdCwt.processToBeRedacted(claims, { hashAlg: hashAlgorithm, strict });\n\n    // Encode claims as CBOR payload\n    const payload = cbor.encode(processedClaims);\n\n    // Build custom protected headers for SD-CWT\n    const customProtectedHeaders = new Map();\n    \n    // Add typ header for SD-CWT\n    customProtectedHeaders.set(sdCwt.HeaderParam.Typ, sdCwt.MediaType.SdCwt);\n    \n    // Add sd_alg header if there are disclosures\n    if (disclosures.length > 0) {\n      customProtectedHeaders.set(sdCwt.HeaderParam.SdAlg, sdCwt.SdAlg.SHA256);\n    }\n\n    // Sign the token\n    const token = await coseSign1.sign(payload, privateKey, {\n      algorithm,\n      kid,\n      customProtectedHeaders: customProtectedHeaders.size > 0 ? customProtectedHeaders : undefined,\n    });\n\n    return { token, disclosures };\n  },\n};\n\n/**\n * SD-CWT Holder API\n * \n * Allows holders to select which disclosures to present,\n * enabling selective disclosure of claims.\n * Per spec Section 8.1: Holder MUST create a Key Binding Token (SD-KBT) for every presentation.\n */\nexport const Holder = {\n  /**\n   * Parses an SD-CWT token to extract the redacted claims structure.\n   * Does not verify the signature.\n   * \n   * @param {Buffer|Uint8Array} token - The SD-CWT token\n   * @returns {{claims: Map, protectedHeaders: Map, unprotectedHeaders: Map}} Parsed token data\n   */\n  parse(token) {\n    const { protectedHeaders, unprotectedHeaders } = coseSign1.getHeaders(token);\n    \n    // Decode the token to get the payload\n    const decoded = cbor.decode(token, sdCwt.cborDecodeOptions);\n    \n    // COSE_Sign1 structure: [protected, unprotected, payload, signature]\n    // But it's wrapped in a tag, so we need the contents\n    const coseArray = decoded.contents || decoded;\n    const payloadBytes = coseArray[2];\n    \n    const claims = cbor.decode(payloadBytes, sdCwt.cborDecodeOptions);\n\n    return { claims, protectedHeaders, unprotectedHeaders };\n  },\n\n  /**\n   * Selects which disclosures to present based on claim names/keys.\n   * \n   * @param {Uint8Array[]} allDisclosures - All disclosures from the issuer\n   * @param {Array<string|number>} claimNames - Claim names/keys to disclose\n   * @returns {Uint8Array[]} Selected disclosures for presentation\n   */\n  selectDisclosures(allDisclosures, claimNames) {\n    const selectedDisclosures = [];\n    const claimNameSet = new Set(claimNames);\n\n    for (const disclosure of allDisclosures) {\n      const decoded = sdCwt.decodeDisclosure(disclosure);\n      \n      // Check if this is a claim-key disclosure (has claimName)\n      if (decoded.claimName !== undefined && claimNameSet.has(decoded.claimName)) {\n        selectedDisclosures.push(disclosure);\n      }\n      \n      // For array element disclosures (no claimName), include if value matches\n      // This allows selecting array elements by their value\n      if (decoded.claimName === undefined && !decoded.isDecoy) {\n        if (claimNames.includes(decoded.value)) {\n          selectedDisclosures.push(disclosure);\n        }\n      }\n    }\n\n    return selectedDisclosures;\n  },\n\n  /**\n   * Creates a Key Binding Token (SD-KBT) presentation per spec Section 8.1.\n   * \n   * The SD-KBT is a COSE_Sign1 signed by the Holder's private key that:\n   * - Contains the SD-CWT (with disclosures) in the kcwt protected header\n   * - Has aud (audience) claim REQUIRED per spec\n   * - Has iat (issued at) claim REQUIRED per spec\n   * - Optionally includes cnonce (client nonce)\n   * \n   * @param {Object} options - Presentation options\n   * @param {Buffer|Uint8Array} options.token - The original SD-CWT token\n   * @param {Uint8Array[]} options.selectedDisclosures - Disclosures to include\n   * @param {Object} options.holderPrivateKey - Holder's private key (matching cnf in SD-CWT)\n   * @param {string} options.audience - The intended verifier (aud claim) - REQUIRED\n   * @param {Uint8Array|Buffer} [options.nonce] - Optional nonce from verifier (cnonce claim)\n   * @param {string} [options.algorithm='ES256'] - Signing algorithm\n   * @returns {Promise<Buffer>} The signed SD-KBT presentation\n   */\n  async present({ token, selectedDisclosures, holderPrivateKey, audience, nonce, algorithm = 'ES256' }) {\n    if (!audience) {\n      throw new Error('audience (aud) is REQUIRED in SD-KBT per spec Section 8.1');\n    }\n    if (!holderPrivateKey) {\n      throw new Error('holderPrivateKey is REQUIRED to sign the SD-KBT');\n    }\n\n    // Debug: Log token info at start\n    console.log('[Holder.present] token type:', token?.constructor?.name);\n    console.log('[Holder.present] token length:', token?.length);\n    console.log('[Holder.present] token instanceof Uint8Array:', token instanceof Uint8Array);\n\n    // Ensure token is Uint8Array\n    const tokenBytes = Buffer.isBuffer(token) \n      ? new Uint8Array(token.buffer, token.byteOffset, token.length)\n      : (token instanceof Uint8Array ? token : new Uint8Array(token));\n    \n    console.log('[Holder.present] tokenBytes length:', tokenBytes?.length);\n    \n    // Ensure disclosures are Uint8Arrays\n    const disclosureBytes = selectedDisclosures.map(d => \n      Buffer.isBuffer(d) \n        ? new Uint8Array(d.buffer, d.byteOffset, d.length)\n        : (d instanceof Uint8Array ? d : new Uint8Array(d))\n    );\n\n    // Build the SD-CWT with disclosures in unprotected header\n    // We need to re-encode the SD-CWT with disclosures in the unprotected header\n    const sdCwtWithDisclosures = embedDisclosuresInToken(tokenBytes, disclosureBytes);\n\n    // Build SD-KBT payload per spec Section 8.1\n    // REQUIRED: aud (3), iat (6)\n    // OPTIONAL: cnonce (39), exp, nbf\n    const kbtPayload = new Map([\n      [sdCwt.ClaimKey.Aud, audience],\n      [sdCwt.ClaimKey.Iat, Math.floor(Date.now() / 1000)],\n    ]);\n\n    if (nonce) {\n      const nonceBytes = Buffer.isBuffer(nonce)\n        ? new Uint8Array(nonce.buffer, nonce.byteOffset, nonce.length)\n        : (nonce instanceof Uint8Array ? nonce : new Uint8Array(nonce));\n      kbtPayload.set(sdCwt.ClaimKey.Cnonce, nonceBytes);\n    }\n\n    // Build SD-KBT protected headers\n    // REQUIRED: typ, alg, kcwt (containing SD-CWT)\n    const kbtProtectedHeaders = new Map([\n      [sdCwt.HeaderParam.Typ, sdCwt.MediaType.KbCwt],\n      [sdCwt.HeaderParam.Kcwt, sdCwtWithDisclosures],\n    ]);\n\n    // Encode the payload\n    const payloadEncoded = cbor.encode(kbtPayload);\n\n    // Sign the SD-KBT with Holder's private key\n    const kbt = await coseSign1.sign(payloadEncoded, holderPrivateKey, {\n      algorithm,\n      customProtectedHeaders: kbtProtectedHeaders,\n    });\n\n    return kbt;\n  },\n\n  /**\n   * Filters disclosures by matching against redacted hashes in the claims.\n   * Only returns disclosures that match actual redacted entries.\n   * \n   * @param {Map} claims - The redacted claims from the token\n   * @param {Uint8Array[]} disclosures - Disclosures to filter\n   * @param {string} [hashAlgorithm='sha256'] - Hash algorithm used\n   * @returns {Uint8Array[]} Valid disclosures that match redacted entries\n   */\n  filterValidDisclosures(claims, disclosures, hashAlgorithm = 'sha256') {\n    // Build set of all redacted hashes in the claims\n    const redactedHashes = new Set();\n    collectRedactedHashes(claims, redactedHashes);\n\n    // Filter disclosures that match\n    const validDisclosures = [];\n    for (const disclosure of disclosures) {\n      const hash = sdCwt.hashDisclosure(disclosure, hashAlgorithm);\n      const hexHash = Buffer.from(hash).toString('hex');\n      if (redactedHashes.has(hexHash)) {\n        validDisclosures.push(disclosure);\n      }\n    }\n\n    return validDisclosures;\n  },\n};\n\n/**\n * Embeds disclosures into the SD-CWT's unprotected header\n * Per RFC 9528 Section 4.4.1: kcwt contains a CWT but without the CBOR tag.\n * So we return the COSE_Sign1 array wrapped in Tag 18 (as raw bytes).\n * \n * @param {Uint8Array} token - The original SD-CWT\n * @param {Uint8Array[]} disclosures - The disclosures to embed\n * @returns {Uint8Array} The SD-CWT with disclosures in unprotected header\n */\nfunction embedDisclosuresInToken(token, disclosures) {\n  // Decode the COSE_Sign1 structure\n  const decoded = cbor.decode(token, sdCwt.cborDecodeOptions);\n  const coseArray = decoded.contents || decoded;\n  \n  // COSE_Sign1: [protected, unprotected, payload, signature]\n  const [protectedBytes, unprotectedMap, payload, signature] = coseArray;\n  \n  // Debug: Log signature info\n  console.log('[embedDisclosuresInToken] signature type:', signature?.constructor?.name);\n  console.log('[embedDisclosuresInToken] signature length:', signature?.length);\n  console.log('[embedDisclosuresInToken] signature instanceof Uint8Array:', signature instanceof Uint8Array);\n  if (signature && signature.length > 0) {\n    console.log('[embedDisclosuresInToken] first 5 bytes:', Array.from(signature.slice(0, 5)).map(b => b.toString(16).padStart(2, '0')).join(''));\n  }\n  \n  // Add disclosures to unprotected header\n  const newUnprotected = unprotectedMap instanceof Map ? new Map(unprotectedMap) : new Map();\n  newUnprotected.set(sdCwt.HeaderParam.SdClaims, disclosures);\n  \n  // Re-encode as COSE_Sign1 (tag 18) and return as Uint8Array\n  // The kcwt header expects raw CBOR bytes of the CWT\n  const newCoseArray = [protectedBytes, newUnprotected, payload, signature];\n  const encoded = cbor.encode(new cbor.Tag(18, newCoseArray));\n  // Ensure it's a Uint8Array (not Buffer) for proper handling\n  return Buffer.isBuffer(encoded) \n    ? new Uint8Array(encoded.buffer, encoded.byteOffset, encoded.length)\n    : new Uint8Array(encoded);\n}\n\n/**\n * Recursively collects all redacted hashes from claims\n */\nfunction collectRedactedHashes(claims, hashSet) {\n  if (claims instanceof Map) {\n    for (const [key, value] of claims) {\n      if (sdCwt.isRedactedKeysKey(key)) {\n        // This is the array of redacted key hashes\n        for (const hash of value) {\n          const hashBytes = hash instanceof Uint8Array ? hash : new Uint8Array(hash);\n          hashSet.add(Buffer.from(hashBytes).toString('hex'));\n        }\n      } else if (value instanceof Map) {\n        collectRedactedHashes(value, hashSet);\n      } else if (Array.isArray(value)) {\n        collectRedactedHashesFromArray(value, hashSet);\n      }\n    }\n  }\n}\n\nfunction collectRedactedHashesFromArray(array, hashSet) {\n  for (const element of array) {\n    if (sdCwt.isRedactedClaimElement(element)) {\n      const hashBytes = element.contents instanceof Uint8Array \n        ? element.contents \n        : new Uint8Array(element.contents);\n      hashSet.add(Buffer.from(hashBytes).toString('hex'));\n    } else if (element instanceof Map) {\n      collectRedactedHashes(element, hashSet);\n    } else if (Array.isArray(element)) {\n      collectRedactedHashesFromArray(element, hashSet);\n    }\n  }\n}\n\n/**\n * SD-CWT Verifier API\n * \n * Verifies SD-CWT presentations (SD-KBT) and reconstructs disclosed claims.\n * Per spec Section 9: Verifier MUST validate both the SD-KBT and the embedded SD-CWT.\n */\nexport const Verifier = {\n  /**\n   * Verifies an SD-KBT (Key Binding Token) presentation per spec Section 9.\n   * \n   * This function:\n   * 1. Extracts the SD-CWT from the kcwt header in the SD-KBT\n   * 2. Verifies the SD-CWT signature using the Issuer's public key\n   * 3. Extracts the confirmation key (cnf) from the SD-CWT\n   * 4. Verifies the SD-KBT signature using the confirmation key\n   * 5. Validates audience matches the expected value\n   * 6. Validates nonce if provided\n   * 7. Reconstructs claims from disclosures\n   * \n   * @param {Object} options - Verification options\n   * @param {Buffer|Uint8Array} options.presentation - The SD-KBT presentation\n   * @param {Object} options.issuerPublicKey - Issuer's public key {x, y}\n   * @param {string} options.expectedAudience - The expected audience value (REQUIRED per spec Section 9)\n   * @param {Uint8Array|Buffer} [options.expectedNonce] - Expected nonce if one was sent to Holder\n   * @param {string} [options.hashAlgorithm='sha256'] - Hash algorithm used\n   * @param {boolean} [options.strict=false] - If true, enforce max depth of 16 (per spec section 6.5)\n   * @param {boolean} [options.requireClean=false] - If true, verify claims have no remaining SD-CWT artifacts\n   * @returns {Promise<{claims: Map, redactedKeys: Uint8Array[], sdCwtClaims: Map, kbtPayload: Map, headers: Object}>} Verified result\n   * @throws {Error} If verification fails\n   * \n   * @example\n   * const result = await Verifier.verify({\n   *   presentation: kbt,\n   *   issuerPublicKey: issuerKey.publicKey,\n   *   expectedAudience: 'https://verifier.example/app',\n   * });\n   */\n  async verify({ presentation, issuerPublicKey, expectedAudience, expectedNonce, hashAlgorithm = 'sha256', strict = false, requireClean = false }) {\n    if (!expectedAudience) {\n      throw new Error('expectedAudience is REQUIRED per spec Section 9 Step 6');\n    }\n\n    // Step 1: Parse the SD-KBT and extract the SD-CWT from kcwt header\n    const kbtHeaders = coseSign1.getHeaders(presentation);\n    let sdCwtBytes = kbtHeaders.protectedHeaders.get(sdCwt.HeaderParam.Kcwt);\n    \n    if (!sdCwtBytes) {\n      throw new Error('Invalid SD-KBT: missing kcwt header parameter containing SD-CWT');\n    }\n\n    // Handle case where kcwt was decoded as a CBOR Tag or Array instead of bytes\n    // The CBOR library may decode embedded CBOR structures\n    if (sdCwtBytes instanceof cbor.Tag) {\n      // It's a decoded CBOR Tag, re-encode to bytes\n      sdCwtBytes = cbor.encode(sdCwtBytes);\n    } else if (Array.isArray(sdCwtBytes) && sdCwtBytes.length === 4) {\n      // It's a decoded COSE_Sign1 array, wrap in Tag and encode\n      sdCwtBytes = cbor.encode(new cbor.Tag(18, sdCwtBytes));\n    }\n\n    // Ensure sdCwtBytes is Uint8Array\n    if (Buffer.isBuffer(sdCwtBytes)) {\n      sdCwtBytes = new Uint8Array(sdCwtBytes.buffer, sdCwtBytes.byteOffset, sdCwtBytes.length);\n    }\n\n    // Validate SD-KBT typ header\n    const kbtTyp = kbtHeaders.protectedHeaders.get(sdCwt.HeaderParam.Typ);\n    if (kbtTyp !== sdCwt.MediaType.KbCwt) {\n      throw new Error(`Invalid SD-KBT: typ must be \"${sdCwt.MediaType.KbCwt}\", got \"${kbtTyp}\"`);\n    }\n\n    // Step 2: Verify the SD-CWT signature using Issuer's public key\n    const sdCwtPayloadBytes = await coseSign1.verify(sdCwtBytes, issuerPublicKey);\n    const sdCwtClaims = cbor.decode(sdCwtPayloadBytes, sdCwt.cborDecodeOptions);\n\n    // Step 3: Extract the confirmation key from cnf claim\n    const cnfClaim = sdCwtClaims.get(sdCwt.ClaimKey.Cnf);\n    if (!cnfClaim) {\n      throw new Error('Invalid SD-CWT: missing cnf (8) claim with Holder confirmation key');\n    }\n\n    // Extract the public key from cnf claim\n    // cnf structure: { 1: { 1: kty, -1: crv, -2: x, -3: y } } (COSE_Key in map)\n    const holderPublicKey = extractPublicKeyFromCnf(cnfClaim);\n\n    // Step 4: Verify the SD-KBT signature using the confirmation key\n    const kbtPayloadBytes = await coseSign1.verify(presentation, holderPublicKey);\n    const kbtPayload = cbor.decode(kbtPayloadBytes, sdCwt.cborDecodeOptions);\n\n    // Step 5: Validate SD-KBT has required claims (aud, iat)\n    const kbtAud = kbtPayload.get(sdCwt.ClaimKey.Aud);\n    if (!kbtAud) {\n      throw new Error('Invalid SD-KBT: missing aud (3) claim');\n    }\n    const kbtIat = kbtPayload.get(sdCwt.ClaimKey.Iat);\n    if (kbtIat === undefined) {\n      throw new Error('Invalid SD-KBT: missing iat (6) claim');\n    }\n\n    // Step 6: Validate audience matches\n    if (kbtAud !== expectedAudience) {\n      throw new Error(`Audience mismatch: expected \"${expectedAudience}\", got \"${kbtAud}\"`);\n    }\n\n    // Validate SD-CWT audience if present\n    const sdCwtAud = sdCwtClaims.get(sdCwt.ClaimKey.Aud);\n    if (sdCwtAud && sdCwtAud !== expectedAudience) {\n      throw new Error(`SD-CWT audience mismatch: expected \"${expectedAudience}\", got \"${sdCwtAud}\"`);\n    }\n\n    // Validate nonce if expected\n    if (expectedNonce) {\n      const kbtNonce = kbtPayload.get(sdCwt.ClaimKey.Cnonce);\n      if (!kbtNonce) {\n        throw new Error('Expected nonce (cnonce) but none present in SD-KBT');\n      }\n      const expectedBytes = Buffer.isBuffer(expectedNonce) \n        ? expectedNonce \n        : Buffer.from(expectedNonce);\n      const actualBytes = Buffer.isBuffer(kbtNonce) \n        ? kbtNonce \n        : Buffer.from(kbtNonce);\n      if (!expectedBytes.equals(actualBytes)) {\n        throw new Error('Nonce mismatch');\n      }\n    }\n\n    // Step 7: Extract disclosures from SD-CWT unprotected header\n    const sdCwtHeaders = coseSign1.getHeaders(sdCwtBytes);\n    const disclosures = sdCwtHeaders.unprotectedHeaders.get(sdCwt.HeaderParam.SdClaims) || [];\n\n    // Validate disclosures match redacted entries\n    const validatedDisclosures = validateDisclosures(sdCwtClaims, disclosures, hashAlgorithm);\n\n    // Reconstruct claims with the provided disclosures\n    const { claims, redactedKeys } = sdCwt.reconstructClaims(\n      sdCwtClaims, \n      validatedDisclosures, \n      { hashAlg: hashAlgorithm, strict }\n    );\n\n    // Optionally verify that claims are clean\n    if (requireClean) {\n      sdCwt.assertClaimsClean(claims, { strict });\n      if (redactedKeys.length > 0) {\n        throw new Error(`Claims contain SD-CWT artifacts:\\n${redactedKeys.length} undisclosed redacted key(s) remain`);\n      }\n    }\n\n    return {\n      claims,\n      redactedKeys,\n      sdCwtClaims, // Original SD-CWT claims (for inspection)\n      kbtPayload,  // SD-KBT payload (aud, iat, cnonce)\n      headers: {\n        sdCwt: {\n          protected: sdCwtHeaders.protectedHeaders,\n          unprotected: sdCwtHeaders.unprotectedHeaders,\n        },\n        kbt: {\n          protected: kbtHeaders.protectedHeaders,\n          unprotected: kbtHeaders.unprotectedHeaders,\n        },\n      },\n    };\n  },\n\n  /**\n   * Verifies a raw SD-CWT token with separate disclosures (no key binding).\n   * \n   * WARNING: This method does NOT verify key binding. Per spec, SD-CWT requires\n   * key binding (SD-KBT). Use verify() for spec-compliant verification.\n   * \n   * This method is provided for testing and backwards compatibility only.\n   * \n   * @param {Object} options - Verification options\n   * @param {Buffer|Uint8Array} options.token - The SD-CWT token\n   * @param {Uint8Array[]} options.disclosures - Disclosures to apply\n   * @param {Object} options.publicKey - Issuer's public key {x, y}\n   * @param {string} [options.hashAlgorithm='sha256'] - Hash algorithm used\n   * @param {boolean} [options.strict=false] - If true, enforce max depth of 16\n   * @param {boolean} [options.requireClean=false] - If true, verify claims have no remaining SD-CWT artifacts\n   * @returns {Promise<{claims: Map, redactedKeys: Uint8Array[], headers: Object}>} Verified result\n   * @deprecated Use verify() with proper SD-KBT presentation for spec compliance\n   */\n  async verifyWithoutKeyBinding({ token, disclosures, publicKey, hashAlgorithm = 'sha256', strict = false, requireClean = false }) {\n    // Verify the COSE signature\n    const payloadBytes = await coseSign1.verify(token, publicKey);\n\n    // Decode the verified payload as claims\n    const redactedClaims = cbor.decode(payloadBytes, sdCwt.cborDecodeOptions);\n\n    // Validate disclosures match redacted entries\n    const validatedDisclosures = validateDisclosures(redactedClaims, disclosures, hashAlgorithm);\n\n    // Reconstruct claims with the provided disclosures\n    const { claims, redactedKeys } = sdCwt.reconstructClaims(\n      redactedClaims, \n      validatedDisclosures, \n      { hashAlg: hashAlgorithm, strict }\n    );\n\n    // Optionally verify that claims are clean\n    if (requireClean) {\n      sdCwt.assertClaimsClean(claims, { strict });\n      if (redactedKeys.length > 0) {\n        throw new Error(`Claims contain SD-CWT artifacts:\\n${redactedKeys.length} undisclosed redacted key(s) remain`);\n      }\n    }\n\n    // Get headers for metadata\n    const { protectedHeaders, unprotectedHeaders } = coseSign1.getHeaders(token);\n\n    return {\n      claims,\n      redactedKeys,\n      headers: {\n        protected: protectedHeaders,\n        unprotected: unprotectedHeaders,\n      },\n    };\n  },\n};\n\n/**\n * Extracts a public key from a cnf claim structure\n * @param {Map|Object} cnfClaim - The cnf claim value\n * @returns {Object} The public key {x, y}\n */\nfunction extractPublicKeyFromCnf(cnfClaim) {\n  // cnf can be a Map or object with key 1 (COSE_Key)\n  let coseKey;\n  if (cnfClaim instanceof Map) {\n    coseKey = cnfClaim.get(1); // COSE_Key\n  } else if (typeof cnfClaim === 'object') {\n    coseKey = cnfClaim[1];\n  }\n\n  if (!coseKey) {\n    throw new Error('Invalid cnf claim: missing COSE_Key (key 1)');\n  }\n\n  // Extract x and y coordinates from COSE_Key\n  let x, y;\n  if (coseKey instanceof Map) {\n    x = coseKey.get(-2);\n    y = coseKey.get(-3);\n  } else if (typeof coseKey === 'object') {\n    x = coseKey[-2] || coseKey['-2'];\n    y = coseKey[-3] || coseKey['-3'];\n  }\n\n  if (!x || !y) {\n    throw new Error('Invalid COSE_Key in cnf: missing x (-2) or y (-3) coordinates');\n  }\n\n  return { x, y };\n}\n\n/**\n * Validates that disclosures match actual redacted entries in the claims.\n * Returns only the valid disclosures (filters out any that don't match).\n * \n * @param {Map} redactedClaims - The redacted claims from the token\n * @param {Uint8Array[]} disclosures - Disclosures to validate\n * @param {string} hashAlgorithm - Hash algorithm used\n * @returns {Uint8Array[]} Valid disclosures\n */\nfunction validateDisclosures(redactedClaims, disclosures, hashAlgorithm) {\n  // Build set of all redacted hashes\n  const redactedHashes = new Set();\n  collectRedactedHashes(redactedClaims, redactedHashes);\n\n  // Validate and filter disclosures\n  const validDisclosures = [];\n  \n  for (const disclosure of disclosures) {\n    const hash = sdCwt.hashDisclosure(disclosure, hashAlgorithm);\n    const hexHash = Buffer.from(hash).toString('hex');\n    \n    if (!redactedHashes.has(hexHash)) {\n      // Disclosure doesn't match any redacted entry - this is suspicious\n      // but we'll just filter it out rather than fail completely\n      console.warn('Warning: Disclosure does not match any redacted entry');\n      continue;\n    }\n\n    validDisclosures.push(disclosure);\n  }\n\n  return validDisclosures;\n}\n\n/**\n * Utility functions for working with SD-CWT\n */\nexport const Utils = {\n  /**\n   * Decodes a disclosure to inspect its contents.\n   * \n   * @param {Uint8Array} disclosure - The disclosure to decode\n   * @returns {{salt: Uint8Array, value: any, claimName?: string|number, isDecoy?: boolean}}\n   */\n  decodeDisclosure: sdCwt.decodeDisclosure,\n\n  /**\n   * Computes the hash of a disclosure.\n   * \n   * @param {Uint8Array} disclosure - The disclosure\n   * @param {string} [algorithm='sha256'] - Hash algorithm\n   * @returns {Uint8Array} The hash\n   */\n  hashDisclosure: sdCwt.hashDisclosure,\n\n  /**\n   * Checks if a claims map has any redacted entries.\n   * \n   * @param {Map} claims - The claims to check\n   * @returns {boolean} True if there are redacted entries\n   */\n  hasRedactions(claims) {\n    for (const [key, value] of claims) {\n      if (sdCwt.isRedactedKeysKey(key)) {\n        return true;\n      }\n      if (value instanceof Map && this.hasRedactions(value)) {\n        return true;\n      }\n      if (Array.isArray(value)) {\n        for (const element of value) {\n          if (sdCwt.isRedactedClaimElement(element)) {\n            return true;\n          }\n          if (element instanceof Map && this.hasRedactions(element)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Counts the number of redacted entries in claims.\n   * \n   * @param {Map} claims - The claims to analyze\n   * @returns {{mapKeys: number, arrayElements: number, total: number}} Redaction counts\n   */\n  countRedactions(claims) {\n    let mapKeys = 0;\n    let arrayElements = 0;\n\n    function countInMap(map) {\n      for (const [key, value] of map) {\n        if (sdCwt.isRedactedKeysKey(key)) {\n          mapKeys += value.length;\n        } else if (value instanceof Map) {\n          countInMap(value);\n        } else if (Array.isArray(value)) {\n          countInArray(value);\n        }\n      }\n    }\n\n    function countInArray(array) {\n      for (const element of array) {\n        if (sdCwt.isRedactedClaimElement(element)) {\n          arrayElements++;\n        } else if (element instanceof Map) {\n          countInMap(element);\n        } else if (Array.isArray(element)) {\n          countInArray(element);\n        }\n      }\n    }\n\n    countInMap(claims);\n    return { mapKeys, arrayElements, total: mapKeys + arrayElements };\n  },\n\n  /**\n   * Lists all claim names/keys that are currently redacted.\n   * Only works for map key redactions, not array elements.\n   * Requires disclosures to determine the original claim names.\n   * \n   * @param {Uint8Array[]} disclosures - All available disclosures\n   * @returns {Array<string|number>} List of redacted claim names\n   */\n  getDisclosableClaimNames(disclosures) {\n    const names = [];\n    for (const disclosure of disclosures) {\n      const decoded = sdCwt.decodeDisclosure(disclosure);\n      if (decoded.claimName !== undefined) {\n        names.push(decoded.claimName);\n      }\n    }\n    return names;\n  },\n\n  /**\n   * CBOR decode options that ensure Maps are decoded properly.\n   */\n  cborDecodeOptions: sdCwt.cborDecodeOptions,\n};\n\n"],
  "mappings": "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",
  "names": ["HeaderParam", "generateKeyPair", "i", "b", "Buffer", "o", "O", "t", "s", "l", "b", "d", "f", "e", "t", "n", "o", "f", "n", "e", "r", "a", "r", "n", "f", "l", "t", "o", "a", "s", "e", "i", "d", "u", "_e", "s", "e", "t", "n", "f", "c", "d", "u", "a", "n", "l", "s", "t", "r", "o", "e", "_i", "_e", "t", "i", "s", "o", "e", "n", "t", "r", "f", "a", "s", "i", "l", "p", "i", "b", "n", "s", "c", "U", "h", "f", "y", "e", "n", "T", "t", "r", "s", "i", "p", "N", "E", "o", "c", "u", "R", "g", "b", "R", "e", "n", "t", "r", "i", "o", "b", "c", "p", "g", "s", "N", "u", "E", "y", "w", "A", "T", "U", "h", "o", "e", "_t", "e", "i", "r", "t", "p", "_t", "_r", "_e", "_i", "n_fn", "t", "r", "c", "i", "n", "e", "f", "a", "o", "h", "y", "A", "k", "d", "r", "i", "_e", "_t", "e", "t", "s", "l", "n", "c", "o", "f", "y", "y", "g", "a", "m", "l", "n", "p", "t", "o", "r", "e", "T", "u", "s", "i", "c", "H", "_a", "A", "a", "f", "e", "n", "k", "t", "O", "y", "x", "r", "p", "s", "o", "m", "i", "l", "c", "g", "d", "h", "$", "w", "D", "v", "q", "S", "O", "e", "f", "U", "r", "n", "t", "o", "d", "u", "y", "g", "R", "h", "N", "T", "$", "p", "I", "c", "l", "x", "w", "o", "c", "i", "e", "d", "n", "t", "r", "l", "y", "o", "_t", "_e", "n_fn", "O", "b", "d", "generateKeyPair", "sign", "verify", "K", "x", "n", "y", "z", "H", "i", "t", "a", "b", "c", "d", "e", "f", "g", "h", "T2", "sign", "Buffer", "verify", "l", "k", "v", "sign", "key", "Buffer", "verify", "generateKeyPair", "k", "v", "HeaderParam", "cborDecodeOptions", "HeaderParam", "cborDecodeOptions", "t", "i", "l", "Buffer", "i", "HeaderParam", "sign", "l", "cborDecodeOptions", "Buffer", "d", "b", "verify", "x", "y", "b", "i", "Buffer", "k", "v"]
}
